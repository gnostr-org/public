import debug$1 from 'debug';
import EventEmitter from 'eventemitter3';
import { Sub, Filter } from 'nostr-tools';

type NDKRelayScore = number;

declare enum NDKRelayStatus {
    CONNECTING = 0,
    CONNECTED = 1,
    DISCONNECTING = 2,
    DISCONNECTED = 3,
    RECONNECTING = 4,
    FLAPPING = 5
}
interface NDKRelayConnectionStats {
    /**
     * The number of times a connection has been attempted.
     */
    attempts: number;
    /**
     * The number of times a connection has been successfully established.
     */
    success: number;
    /**
     * The durations of the last 100 connections in milliseconds.
     */
    durations: number[];
    /**
     * The time the current connection was established in milliseconds.
     */
    connectedAt?: number;
}
/**
 * The NDKRelay class represents a connection to a relay.
 *
 * @emits NDKRelay#connect
 * @emits NDKRelay#disconnect
 * @emits NDKRelay#notice
 * @emits NDKRelay#event
 * @emits NDKRelay#published when an event is published to the relay
 * @emits NDKRelay#publish:failed when an event fails to publish to the relay
 * @emits NDKRelay#eose
 */
declare class NDKRelay extends EventEmitter {
    readonly url: string;
    readonly scores: Map<NDKUser, NDKRelayScore>;
    private relay;
    private _status;
    private connectedAt?;
    private _connectionStats;
    complaining: boolean;
    private debug;
    /**
     * Active subscriptions this relay is connected to
     */
    activeSubscriptions: Set<NDKSubscription>;
    constructor(url: string);
    /**
     * Evaluates the connection stats to determine if the relay is flapping.
     */
    private isFlapping;
    /**
     * Called when the relay is unexpectedly disconnected.
     */
    private handleReconnection;
    get status(): NDKRelayStatus;
    /**
     * Connects to the relay.
     */
    connect(): Promise<void>;
    /**
     * Disconnects from the relay.
     */
    disconnect(): void;
    handleNotice(notice: string): Promise<void>;
    /**
     * Subscribes to a subscription.
     */
    subscribe(subscription: NDKSubscription): Sub;
    /**
     * Publishes an event to the relay with an optional timeout.
     *
     * If the relay is not connected, the event will be published when the relay connects,
     * unless the timeout is reached before the relay connects.
     *
     * @param event The event to publish
     * @param timeoutMs The timeout for the publish operation in milliseconds
     * @returns A promise that resolves when the event has been published or rejects if the operation times out
     */
    publish(event: NDKEvent, timeoutMs?: number): Promise<boolean>;
    private publishEvent;
    /**
     * Called when this relay has responded with an event but
     * wasn't the fastest one.
     * @param timeDiffInMs The time difference in ms between the fastest and this relay in milliseconds
     */
    scoreSlowerEvent(timeDiffInMs: number): void;
    /**
     * Utility functions to update the connection stats.
     */
    private updateConnectionStats;
    /**
     * Returns the connection stats.
     */
    get connectionStats(): NDKRelayConnectionStats;
    tagReference(marker?: string): NDKTag;
}

/**
 * A relay set is a group of relays. This grouping can be short-living, for a single
 * REQ or can be long-lasting, for example for the explicit relay list the user
 * has specified.
 *
 * Requests to relays should be sent through this interface.
 */
declare class NDKRelaySet {
    readonly relays: Set<NDKRelay>;
    private debug;
    private ndk;
    constructor(relays: Set<NDKRelay>, ndk: NDK);
    /**
     * Creates a relay set from a list of relay URLs.
     *
     * This is useful for testing in development to pass a local relay
     * to publish methods.
     *
     * @param relayUrls - list of relay URLs to include in this set
     * @param ndk
     * @returns NDKRelaySet
     */
    static fromRelayUrls(relayUrls: string[], ndk: NDK): NDKRelaySet;
    private subscribeOnRelay;
    /**
     * Calculates an ID of this specific combination of relays.
     */
    getId(): string;
    /**
     * Add a subscription to this relay set
     */
    subscribe(subscription: NDKSubscription): NDKSubscription;
    private executeDelayedSubscription;
    /**
     * This function takes a similar group of subscriptions, merges the filters
     * and sends a single subscription to the relay.
     */
    private executeSubscriptions;
    private executeSubscription;
    /**
     * Publish an event to all relays in this set. Returns the number of relays that have received the event.
     * @param event
     * @param timeoutMs - timeout in milliseconds for each publish operation and connection operation
     * @returns A set where the event was successfully published to
     */
    publish(event: NDKEvent, timeoutMs?: number): Promise<Set<NDKRelay>>;
    size(): number;
}

type NDKFilter = Filter;
interface NDKFilterOptions {
    skipCache?: boolean;
}
declare enum NDKSubscriptionCacheUsage {
    ONLY_CACHE = "ONLY_CACHE",
    CACHE_FIRST = "CACHE_FIRST",
    PARALLEL = "PARALLEL",
    ONLY_RELAY = "ONLY_RELAY"
}
interface NDKSubscriptionOptions {
    closeOnEose: boolean;
    cacheUsage?: NDKSubscriptionCacheUsage;
    /**
     * Groupable subscriptions are created with a slight time
     * delayed to allow similar filters to be grouped together.
     */
    groupable?: boolean;
    /**
     * The delay to use when grouping subscriptions, specified in milliseconds.
     * @default 100
     */
    groupableDelay?: number;
    /**
     * The subscription ID to use for the subscription.
     */
    subId?: string;
}
/**
 * Default subscription options.
 */
declare const defaultOpts: NDKSubscriptionOptions;
/**
 * Represents a subscription to an NDK event stream.
 *
 * @event NDKSubscription#event
 * Emitted when an event is received by the subscription.
 * @param {NDKEvent} event - The event received by the subscription.
 * @param {NDKRelay} relay - The relay that received the event.
 * @param {NDKSubscription} subscription - The subscription that received the event.
 *
 * @event NDKSubscription#event:dup
 * Emitted when a duplicate event is received by the subscription.
 * @param {NDKEvent} event - The duplicate event received by the subscription.
 * @param {NDKRelay} relay - The relay that received the event.
 * @param {number} timeSinceFirstSeen - The time elapsed since the first time the event was seen.
 * @param {NDKSubscription} subscription - The subscription that received the event.
 *
 * @event NDKSubscription#eose - Emitted when all relays have reached the end of the event stream.
 * @param {NDKSubscription} subscription - The subscription that received EOSE.
 *
 * @event NDKSubscription#close - Emitted when the subscription is closed.
 * @param {NDKSubscription} subscription - The subscription that was closed.
 */
declare class NDKSubscription extends EventEmitter {
    readonly subId: string;
    readonly filter: NDKFilter;
    readonly opts: NDKSubscriptionOptions;
    relaySet?: NDKRelaySet;
    ndk: NDK;
    relaySubscriptions: Map<NDKRelay, Sub>;
    private debug;
    /**
     * Events that have been seen by the subscription, with the time they were first seen.
     */
    eventFirstSeen: Map<string, number>;
    /**
     * Relays that have sent an EOSE.
     */
    eosesSeen: Set<NDKRelay>;
    /**
     * Events that have been seen by the subscription per relay.
     */
    eventsPerRelay: Map<NDKRelay, Set<NDKEventId>>;
    constructor(ndk: NDK, filter: NDKFilter, opts?: NDKSubscriptionOptions, relaySet?: NDKRelaySet, subId?: string);
    /**
     * Calculates the groupable ID for this subscription.
     *
     * @returns The groupable ID, or null if the subscription is not groupable.
     */
    groupableId(): string | null;
    private shouldQueryCache;
    private shouldQueryRelays;
    private shouldWaitForCache;
    /**
     * Start the subscription. This is the main method that should be called
     * after creating a subscription.
     */
    start(): Promise<void>;
    stop(): void;
    private startWithCache;
    private startWithRelaySet;
    /**
     * Called when an event is received from a relay or the cache
     * @param event
     * @param relay
     * @param fromCache Whether the event was received from the cache
     */
    eventReceived(event: NDKEvent, relay: NDKRelay | undefined, fromCache?: boolean): void;
    private eoseTimeout;
    eoseReceived(relay: NDKRelay): void;
}
/**
 * Represents a group of subscriptions.
 *
 * Events emitted from the group will be emitted from each subscription.
 */
declare class NDKSubscriptionGroup extends NDKSubscription {
    private subscriptions;
    constructor(ndk: NDK, subscriptions: NDKSubscription[]);
    private isEventForSubscription;
    private forwardEvent;
    private forwardEventDup;
    private forwardEose;
    private forwardClose;
}
/**
 * Go through all the passed filters, which should be
 * relatively similar, and merge them.
 */
declare function mergeFilters(filters: NDKFilter[]): NDKFilter;
/**
 * Creates a valid nostr filter from an event id or a NIP-19 bech32.
 */
declare function filterFromId(id: string): NDKFilter;

/**
 * NDKUserProfile represents a user's kind 0 profile metadata
 */
type NDKUserProfile = {
    [key: string]: string | undefined;
    name?: string;
    displayName?: string;
    image?: string;
    banner?: string;
    bio?: string;
    nip05?: string;
    lud06?: string;
    lud16?: string;
    about?: string;
    zapService?: string;
    website?: string;
};
declare function mergeEvent(event: NDKEvent, profile: NDKUserProfile): NDKUserProfile;

interface NDKUserParams {
    npub?: string;
    hexpubkey?: string;
    nip05?: string;
    relayUrls?: string[];
}
/**
 * Represents a pubkey.
 */
declare class NDKUser {
    ndk: NDK | undefined;
    profile?: NDKUserProfile;
    readonly npub: string;
    readonly relayUrls: string[];
    constructor(opts: NDKUserParams);
    /**
     * Instantiate an NDKUser from a NIP-05 string
     * @param nip05Id {string} The user's NIP-05
     * @returns {NDKUser | undefined} An NDKUser if one is found for the given NIP-05, undefined otherwise.
     */
    static fromNip05(nip05Id: string): Promise<NDKUser | undefined>;
    /**
     * Get the hexpubkey for a user
     * @returns {string} The user's hexpubkey
     */
    hexpubkey(): string;
    /**
     * Fetch a user's kind 0 metadata events and merge the events in a single up-to-date profile
     * @param opts {NDKFilterOptions} A set of NDKFilterOptions
     * @returns {Promise<Set<Event>>} A set of all NDKEvents events returned for the given user
     */
    fetchProfile(opts?: NDKFilterOptions): Promise<Set<NDKEvent> | null>;
    /**
     * Returns a set of users that this user follows.
     */
    follows: () => Promise<Set<NDKUser>>;
    /**
     * Returns a set of relay list events for a user.
     * @returns {Promise<Set<Event>>} A set of NDKEvents returned for the given user.
     */
    relayList(): Promise<Set<NDKEvent>>;
    /**
     * Get the tag that can be used to reference this user in an event
     * @returns {NDKTag} an NDKTag
     */
    tagReference(): NDKTag;
    /**
     * Publishes the current profile.
     */
    publish(): Promise<void>;
    /**
     * Add a follow to this user's contact list
     *
     * @param newFollow {NDKUser} The user to follow
     * @param currentFollowList {Set<NDKUser>} The current follow list
     * @returns {Promise<boolean>} True if the follow was added, false if the follow already exists
     */
    follow(newFollow: NDKUser, currentFollowList?: Set<NDKUser>): Promise<boolean>;
}

/**
 * Interface for NDK signers.
 */
interface NDKSigner {
    /**
     * Blocks until the signer is ready and returns the associated NDKUser.
     * @returns A promise that resolves to the NDKUser instance.
     */
    blockUntilReady(): Promise<NDKUser>;
    /**
     * Getter for the user property.
     * @returns A promise that resolves to the NDKUser instance.
     */
    user(): Promise<NDKUser>;
    /**
     * Signs the given Nostr event.
     * @param event - The Nostr event to be signed.
     * @returns A promise that resolves to the signature of the signed event.
     */
    sign(event: NostrEvent): Promise<string>;
    /**
     * Encrypts the given Nostr event for the given recipient.
     * @param value - The value to be encrypted.
     * @param recipient - The recipient of the encrypted value.
     */
    encrypt(recipient: NDKUser, value: string): Promise<string>;
    /**
     * Decrypts the given value.
     * @param value
     */
    decrypt(sender: NDKUser, value: string): Promise<string>;
}

declare enum NDKKind {
    Metadata = 0,
    Text = 1,
    RecommendRelay = 2,
    Contacts = 3,
    EncryptedDirectMessage = 4,
    EventDeletion = 5,
    Repost = 6,
    Reaction = 7,
    BadgeAward = 8,
    GenericRepost = 16,
    ChannelCreation = 40,
    ChannelMetadata = 41,
    ChannelMessage = 42,
    ChannelHideMessage = 43,
    ChannelMuteUser = 44,
    Report = 1984,
    ZapRequest = 9734,
    Zap = 9735,
    MuteList = 10000,
    PinList = 10001,
    RelayList = 10002,
    ClientAuth = 22242,
    NostrConnect = 24133,
    CategorizedPeopleList = 30000,
    CategorizedBookmarkList = 30001,
    CategorizedRelayList = 30022,
    ProfileBadge = 30008,
    BadgeDefinition = 30009,
    Article = 30023,
    AppSpecificData = 30078
}

type NDKEventId = string;
type NDKTag = string[];
type NostrEvent = {
    created_at: number;
    content: string;
    tags: NDKTag[];
    kind?: NDKKind | number;
    pubkey: string;
    id?: string;
    sig?: string;
};
/**
 * NDKEvent is the basic building block of NDK; most things
 * you do with NDK will revolve around writing or consuming NDKEvents.
 */
declare class NDKEvent extends EventEmitter {
    ndk?: NDK;
    created_at?: number;
    content: string;
    tags: NDKTag[];
    kind?: NDKKind | number;
    id: string;
    sig?: string;
    pubkey: string;
    /**
     * The relay that this event was first received from.
     */
    relay: NDKRelay | undefined;
    constructor(ndk?: NDK, event?: NostrEvent);
    /**
     * Returns the event as is.
     */
    rawEvent(): NostrEvent;
    set author(user: NDKUser);
    /**
     * Returns an NDKUser for the author of the event.
     */
    get author(): NDKUser;
    /**
     * Tag a user with an optional marker.
     * @param user The user to tag.
     * @param marker The marker to use in the tag.
     */
    tag(user: NDKUser, marker?: string): void;
    /**
     * Tag a user with an optional marker.
     * @param event The event to tag.
     * @param marker The marker to use in the tag.
     * @example
     * ```typescript
     * reply.tag(opEvent, "reply");
     * // reply.tags => [["e", <id>, <relay>, "reply"]]
     * ```
     */
    tag(event: NDKEvent, marker?: string): void;
    /**
     * Return a NostrEvent object, trying to fill in missing fields
     * when possible, adding tags when necessary.
     * @param pubkey {string} The pubkey of the user who the event belongs to.
     * @returns {Promise<NostrEvent>} A promise that resolves to a NostrEvent.
     */
    toNostrEvent(pubkey?: string): Promise<NostrEvent>;
    isReplaceable: () => boolean;
    isParamReplaceable: () => boolean;
    encode: () => string;
    encrypt: (recipient?: NDKUser | undefined, signer?: NDKSigner | undefined) => Promise<void>;
    decrypt: (sender?: NDKUser | undefined, signer?: NDKSigner | undefined) => Promise<void>;
    /**
     * Get all tags with the given name
     * @param tagName {string} The name of the tag to search for
     * @returns {NDKTag[]} An array of the matching tags
     */
    getMatchingTags(tagName: string): NDKTag[];
    /**
     * Get the first tag with the given name
     * @param tagName Tag name to search for
     * @returns The value of the first tag with the given name, or undefined if no such tag exists
     */
    tagValue(tagName: string): string | undefined;
    /**
     * Remove all tags with the given name (e.g. "d", "a", "p")
     * @param tagName Tag name to search for and remove
     * @returns {void}
     */
    removeTag(tagName: string): void;
    /**
     * Sign the event if a signer is present.
     *
     * It will generate tags.
     * Repleacable events will have their created_at field set to the current time.
     * @param signer {NDKSigner} The NDKSigner to use to sign the event
     * @returns {Promise<string>} A Promise that resolves to the signature of the signed event.
     */
    sign(signer?: NDKSigner): Promise<string>;
    /**
     * Attempt to sign and then publish an NDKEvent to a given relaySet.
     * If no relaySet is provided, the relaySet will be calculated by NDK.
     * @param relaySet {NDKRelaySet} The relaySet to publish the even to.
     * @returns A promise that resolves to the relays the event was published to.
     */
    publish(relaySet?: NDKRelaySet, timeoutMs?: number): Promise<Set<NDKRelay>>;
    /**
     * Generates tags for users, notes, and other events tagged in content.
     * Will also generate random "d" tag for parameterized replaceable events where needed.
     * @returns {ContentTag} The tags and content of the event.
     */
    private generateTags;
    /**
     * Returns the "d" tag of a parameterized replaceable event or throws an error if the event isn't
     * a parameterized replaceable event.
     * @returns {string} the "d" tag of the event.
     */
    replaceableDTag(): string;
    /**
     * Returns the id of the event or, if it's a parameterized event, the generated id of the event using "d" tag, pubkey, and kind.
     * @returns {string} The id
     */
    tagId(): string;
    /**
     * Get the tag that can be used to reference this event from another event
     * @example
     *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ ["d", "d-code"] ] });
     *     event.tagReference(); // ["a", "30000:pubkey:d-code"]
     *
     *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: "eventid" });
     *     event.tagReference(); // ["e", "eventid"]
     * @returns {NDKTag} The NDKTag object referencing this event
     */
    tagReference(): NDKTag;
    /**
     * Provides the filter that will return matching events for this event.
     *
     * @example
     *    event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ ["d", "d-code"] ] });
     *    event.filter(); // { "#a": ["30000:pubkey:d-code"] }
     * @example
     *    event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: "eventid" });
     *    event.filter(); // { "#e": ["eventid"] }
     *
     * @returns The filter that will return matching events for this event
     */
    filter(): NDKFilter;
    /**
     * Create a zap request for an existing event
     *
     * @param amount The amount to zap in millisatoshis
     * @param comment A comment to add to the zap request
     * @param extraTags Extra tags to add to the zap request
     */
    zap(amount: number, comment?: string, extraTags?: NDKTag[]): Promise<string | null>;
    /**
     * Generates a deletion event of the current event
     *
     * @param reason The reason for the deletion
     * @returns The deletion event
     */
    delete(reason?: string): Promise<NDKEvent>;
    /**
     * NIP-18 reposting event.
     *
     * @param publish Whether to publish the reposted event automatically
     * @param signer The signer to use for signing the reposted event
     * @returns The reposted event
     *
     * @function
     */
    repost: (publish?: boolean | undefined, signer?: NDKSigner | undefined) => Promise<NDKEvent>;
}

interface NDKCacheAdapter {
    /**
     * Whether this cache adapter is expected to be fast.
     * If this is true, the cache will be queried before the relays.
     * When this is false, the cache will be queried in addition to the relays.
     */
    locking: boolean;
    query(subscription: NDKSubscription): Promise<void>;
    setEvent(event: NDKEvent, filter: NDKFilter): Promise<void>;
}

type NDKPoolStats = {
    total: number;
    connected: number;
    disconnected: number;
    connecting: number;
};
/**
 * Handles connections to all relays. A single pool should be used per NDK instance.
 *
 * @emit connect - Emitted when all relays in the pool are connected, or when the specified timeout has elapsed, and some relays are connected.
 * @emit notice - Emitted when a relay in the pool sends a notice.
 * @emit flapping - Emitted when a relay in the pool is flapping.
 * @emit relay:connect - Emitted when a relay in the pool connects.
 * @emit relay:disconnect - Emitted when a relay in the pool disconnects.
 */
declare class NDKPool extends EventEmitter {
    relays: Map<string, NDKRelay>;
    private debug;
    constructor(relayUrls: string[] | undefined, ndk: NDK);
    private handleRelayConnect;
    /**
     * Attempts to establish a connection to each relay in the pool.
     *
     * @async
     * @param {number} [timeoutMs] - Optional timeout in milliseconds for each connection attempt.
     * @returns {Promise<void>} A promise that resolves when all connection attempts have completed.
     * @throws {Error} If any of the connection attempts result in an error or timeout.
     */
    connect(timeoutMs?: number): Promise<void>;
    private handleFlapping;
    size(): number;
    /**
     * Returns the status of each relay in the pool.
     * @returns {NDKPoolStats} An object containing the number of relays in each status.
     */
    stats(): NDKPoolStats;
    /**
     * Get a list of all relay urls in the pool.
     */
    urls(): string[];
}

type NDKListItem = NDKRelay | NDKUser | NDKEvent;
/**
 * Represents any NIP-33 list kind.
 *
 * This class provides some helper methods to manage the list, particularly
 * a CRUD interface to list items.
 *
 * List items can be encrypted or not. Encrypted items are JSON-encoded and
 * self-signed by the user's key.
 *
 * @example Adding an event to the list.
 * const event1 = new NDKEvent(...);
 * const list = new NDKList();
 * list.addItem(event1);
 *
 * @example Adding an encrypted `p` tag to the list with a "person" mark.
 * const secretFollow = new NDKUser(...);
 * list.addItem(secretFollow, 'person', true);
 *
 * @emits NDKList#change
 */
declare class NDKList extends NDKEvent {
    _encryptedTags: NDKTag[] | undefined;
    /**
     * Stores the number of bytes the content was before decryption
     * to expire the cache when the content changes.
     */
    private encryptedTagsLength;
    constructor(ndk?: NDK, rawEvent?: NostrEvent);
    /**
     * Wrap a NDKEvent into a NDKList
     */
    static from(ndkEvent: NDKEvent): NDKList;
    /**
     * Returns the name of the list.
     */
    get name(): string | undefined;
    /**
     * Sets the name of the list.
     */
    set name(name: string | undefined);
    /**
     * Returns the description of the list.
     */
    get description(): string | undefined;
    /**
     * Sets the description of the list.
     */
    set description(name: string | undefined);
    private isEncryptedTagsCacheValid;
    /**
     * Returns the decrypted content of the list.
     */
    encryptedTags(useCache?: boolean): Promise<NDKTag[]>;
    /**
     * This method can be overriden to validate that a tag is valid for this list.
     *
     * (i.e. the NDKPersonList can validate that items are NDKUser instances)
     */
    validateTag(tagValue: string): boolean | string;
    /**
     * Returns the unecrypted items in this list.
     */
    get items(): NDKTag[];
    /**
     * Adds a new item to the list.
     * @param relay Relay to add
     * @param mark Optional mark to add to the item
     * @param encrypted Whether to encrypt the item
     */
    addItem(item: NDKListItem | NDKTag, mark?: string | undefined, encrypted?: boolean): Promise<void>;
    /**
     * Removes an item from the list.
     *
     * @param index The index of the item to remove.
     * @param encrypted Whether to remove from the encrypted list or not.
     */
    removeItem(index: number, encrypted: boolean): Promise<NDKList>;
}

type Nip04QueueItem = {
    type: "encrypt" | "decrypt";
    counterpartyHexpubkey: string;
    value: string;
    resolve: (value: string) => void;
    reject: (reason?: Error) => void;
};
/**
 * NDKNip07Signer implements the NDKSigner interface for signing Nostr events
 * with a NIP-07 browser extension (e.g., getalby, nos2x).
 */
declare class NDKNip07Signer implements NDKSigner {
    private _userPromise;
    nip04Queue: Nip04QueueItem[];
    private nip04Processing;
    private debug;
    constructor();
    blockUntilReady(): Promise<NDKUser>;
    /**
     * Getter for the user property.
     * @returns The NDKUser instance.
     */
    user(): Promise<NDKUser>;
    /**
     * Signs the given Nostr event.
     * @param event - The Nostr event to be signed.
     * @returns The signature of the signed event.
     * @throws Error if the NIP-07 is not available on the window object.
     */
    sign(event: NostrEvent): Promise<string>;
    encrypt(recipient: NDKUser, value: string): Promise<string>;
    decrypt(sender: NDKUser, value: string): Promise<string>;
    private queueNip04;
    private processNip04Queue;
}
declare global {
    interface Window {
        nostr?: {
            getPublicKey(): Promise<string>;
            signEvent(event: NostrEvent): Promise<{
                sig: string;
            }>;
            nip04: {
                encrypt(recipientHexPubKey: string, value: string): Promise<string>;
                decrypt(senderHexPubKey: string, value: string): Promise<string>;
            };
        };
    }
}

type Nip46PermitCallback = (pubkey: string, method: string, params?: any) => Promise<boolean>;
type Nip46ApplyTokenCallback = (pubkey: string, token: string) => Promise<void>;
interface IEventHandlingStrategy {
    handle(backend: NDKNip46Backend, remotePubkey: string, params: string[]): Promise<string | undefined>;
}
/**
 * This class implements a NIP-46 backend, meaning that it will hold a private key
 * of the npub that wants to be published as.
 *
 * This backend is meant to be used by an NDKNip46Signer, which is the class that
 * should run client-side, where the user wants to sign events from.
 */
declare class NDKNip46Backend {
    readonly ndk: NDK;
    readonly signer: NDKPrivateKeySigner;
    localUser?: NDKUser;
    readonly debug: debug.Debugger;
    private rpc;
    private permitCallback;
    /**
     * @param ndk The NDK instance to use
     * @param privateKey The private key of the npub that wants to be published as
     */
    constructor(ndk: NDK, privateKey: string, permitCallback: Nip46PermitCallback);
    /**
     * This method starts the backend, which will start listening for incoming
     * requests.
     */
    start(): Promise<void>;
    handlers: {
        [method: string]: IEventHandlingStrategy;
    };
    /**
     * Enables the user to set a custom strategy for handling incoming events.
     * @param method - The method to set the strategy for
     * @param strategy - The strategy to set
     */
    setStrategy(method: string, strategy: IEventHandlingStrategy): void;
    /**
     * Overload this method to apply tokens, which can
     * wrap permission sets to be applied to a pubkey.
     * @param pubkey public key to apply token to
     * @param token token to apply
     */
    applyToken(pubkey: string, token: string): Promise<void>;
    protected handleIncomingEvent(event: NDKEvent): Promise<void>;
    decrypt(remotePubkey: string, senderUser: NDKUser, payload: string): Promise<string | undefined>;
    encrypt(remotePubkey: string, recipientUser: NDKUser, payload: string): Promise<string | undefined>;
    signEvent(remotePubkey: string, params: string[]): Promise<NDKEvent | undefined>;
    /**
     * This method should be overriden by the user to allow or reject incoming
     * connections.
     */
    pubkeyAllowed(pubkey: string, method: string, params?: any): Promise<boolean>;
}

interface NDKRpcRequest {
    id: string;
    pubkey: string;
    method: string;
    params: string[];
    event: NDKEvent;
}
interface NDKRpcResponse {
    id: string;
    result: string;
    error?: string;
    event: NDKEvent;
}
declare class NDKNostrRpc extends EventEmitter {
    private ndk;
    private signer;
    private debug;
    constructor(ndk: NDK, signer: NDKSigner, debug: debug.Debugger);
    /**
     * Subscribe to a filter. This function will resolve once the subscription is ready.
     */
    subscribe(filter: NDKFilter): Promise<NDKSubscription>;
    parseEvent(event: NDKEvent): Promise<NDKRpcRequest | NDKRpcResponse>;
    sendResponse(id: string, remotePubkey: string, result: string, kind?: number, error?: string): Promise<void>;
    /**
     * Sends a request.
     * @param remotePubkey
     * @param method
     * @param params
     * @param kind
     * @param id
     */
    sendRequest(remotePubkey: string, method: string, params?: string[], kind?: number, cb?: (res: NDKRpcResponse) => void): Promise<NDKRpcResponse>;
}

/**
 * This NDKSigner implements NIP-46, which allows remote signing of events.
 * This class is meant to be used client-side, paired with the NDKNip46Backend or a NIP-46 backend (like Nostr-Connect)
 */
declare class NDKNip46Signer implements NDKSigner {
    private ndk;
    remoteUser: NDKUser;
    remotePubkey: string;
    token: string | undefined;
    localSigner: NDKSigner;
    private rpc;
    private debug;
    /**
     * @param ndk - The NDK instance to use
     * @param token - connection token, in the form "npub#otp"
     * @param localSigner - The signer that will be used to request events to be signed
     */
    constructor(ndk: NDK, token: string, localSigner?: NDKSigner);
    /**
     * @param ndk - The NDK instance to use
     * @param remoteNpub - The npub that wants to be published as
     * @param localSigner - The signer that will be used to request events to be signed
     */
    constructor(ndk: NDK, remoteNpub: string, localSigner?: NDKSigner);
    /**
     * @param ndk - The NDK instance to use
     * @param remotePubkey - The public key of the npub that wants to be published as
     * @param localSigner - The signer that will be used to request events to be signed
     */
    constructor(ndk: NDK, remotePubkey: string, localSigner?: NDKSigner);
    /**
     * Get the user that is being published as
     */
    user(): Promise<NDKUser>;
    blockUntilReady(): Promise<NDKUser>;
    encrypt(recipient: NDKUser, value: string): Promise<string>;
    decrypt(sender: NDKUser, value: string): Promise<string>;
    sign(event: NostrEvent): Promise<string>;
}

declare class NDKPrivateKeySigner implements NDKSigner {
    private _user;
    privateKey?: string;
    constructor(privateKey?: string);
    static generate(): NDKPrivateKeySigner;
    blockUntilReady(): Promise<NDKUser>;
    user(): Promise<NDKUser>;
    sign(event: NostrEvent): Promise<string>;
    encrypt(recipient: NDKUser, value: string): Promise<string>;
    decrypt(sender: NDKUser, value: string): Promise<string>;
}

interface NDKZapInvoice {
    id?: NDKEventId;
    zapper: string;
    zappee: string;
    zapped: string;
    zappedEvent?: string;
    amount: number;
    comment?: string;
}
/**
 * Parses a zap invoice from a kind 9735 event
 *
 * @param event The event to parse
 *
 * @returns NDKZapInvoice | null
 */
declare function zapInvoiceFromEvent(event: NDKEvent): NDKZapInvoice | null;

interface NDKConstructorParams {
    explicitRelayUrls?: string[];
    devWriteRelayUrls?: string[];
    signer?: NDKSigner;
    cacheAdapter?: NDKCacheAdapter;
    debug?: debug$1.Debugger;
}
interface GetUserParams extends NDKUserParams {
    npub?: string;
    hexpubkey?: string;
}
declare class NDK extends EventEmitter {
    pool: NDKPool;
    signer?: NDKSigner;
    cacheAdapter?: NDKCacheAdapter;
    debug: debug$1.Debugger;
    devWriteRelaySet?: NDKRelaySet;
    delayedSubscriptions: Map<string, NDKSubscription[]>;
    constructor(opts?: NDKConstructorParams);
    toJSON(): string;
    /**
     * Connect to relays with optional timeout.
     * If the timeout is reached, the connection will be continued to be established in the background.
     */
    connect(timeoutMs?: number): Promise<void>;
    /**
     * Get a NDKUser object
     *
     * @param opts
     * @returns
     */
    getUser(opts: GetUserParams): NDKUser;
    /**
     * Create a new subscription. Subscriptions automatically start and finish when all relays
     * on the set send back an EOSE. (set `opts.closeOnEose` to `false` in order avoid this)
     *
     * @param filter
     * @param opts
     * @param relaySet explicit relay set to use
     * @param autoStart automatically start the subscription
     * @returns NDKSubscription
     */
    subscribe(filter: NDKFilter, opts?: NDKSubscriptionOptions, relaySet?: NDKRelaySet, autoStart?: boolean): NDKSubscription;
    /**
     * Publish an event to a relay
     * @param event event to publish
     * @param relaySet explicit relay set to use
     * @param timeoutMs timeout in milliseconds to wait for the event to be published
     * @returns The relays the event was published to
     */
    publish(event: NDKEvent, relaySet?: NDKRelaySet, timeoutMs?: number): Promise<Set<NDKRelay>>;
    /**
     * Fetch a single event
     */
    fetchEvent(id: string): Promise<NDKEvent | null>;
    fetchEvent(filter: NDKFilter, opts: NDKFilterOptions): Promise<NDKEvent | null>;
    /**
     * Fetch events
     */
    fetchEvents(filter: NDKFilter, opts?: NDKFilterOptions, relaySet?: NDKRelaySet): Promise<Set<NDKEvent>>;
    /**
     * Ensures that a signer is available to sign an event.
     */
    assertSigner(): Promise<void>;
}

export { GetUserParams, IEventHandlingStrategy, NDKCacheAdapter, NDKConstructorParams, NDKEvent, NDKEventId, NDKFilter, NDKFilterOptions, NDKKind, NDKList, NDKListItem, NDKNip07Signer, NDKNip46Backend, NDKNip46Signer, NDKNostrRpc, NDKPrivateKeySigner, NDKRelay, NDKRelayConnectionStats, NDKRelaySet, NDKRelayStatus, NDKRpcRequest, NDKRpcResponse, NDKSigner, NDKSubscription, NDKSubscriptionCacheUsage, NDKSubscriptionGroup, NDKSubscriptionOptions, NDKTag, NDKUser, NDKUserProfile, NDKZapInvoice, Nip46ApplyTokenCallback, Nip46PermitCallback, NostrEvent, NDK as default, defaultOpts, filterFromId, mergeEvent, mergeFilters, zapInvoiceFromEvent };
