"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  NDKEvent: () => NDKEvent,
  NDKKind: () => NDKKind,
  NDKList: () => NDKList,
  NDKNip07Signer: () => NDKNip07Signer,
  NDKNip46Backend: () => NDKNip46Backend,
  NDKNip46Signer: () => NDKNip46Signer,
  NDKNostrRpc: () => NDKNostrRpc,
  NDKPrivateKeySigner: () => NDKPrivateKeySigner,
  NDKRelay: () => NDKRelay2,
  NDKRelaySet: () => NDKRelaySet2,
  NDKRelayStatus: () => NDKRelayStatus,
  NDKSubscription: () => NDKSubscription,
  NDKSubscriptionCacheUsage: () => NDKSubscriptionCacheUsage,
  NDKSubscriptionGroup: () => NDKSubscriptionGroup,
  NDKUser: () => NDKUser,
  default: () => NDK7,
  defaultOpts: () => defaultOpts,
  filterFromId: () => filterFromId,
  mergeEvent: () => mergeEvent,
  mergeFilters: () => mergeFilters,
  zapInvoiceFromEvent: () => zapInvoiceFromEvent
});
module.exports = __toCommonJS(src_exports);
var import_debug3 = __toESM(require("debug"));
var import_eventemitter37 = __toESM(require("eventemitter3"));

// src/events/dedup.ts
function dedup(event1, event2) {
  if (event1.created_at > event2.created_at) {
    return event1;
  }
  return event2;
}

// src/events/index.ts
var import_eventemitter32 = __toESM(require("eventemitter3"));
var import_nostr_tools6 = require("nostr-tools");

// src/zap/index.ts
var import_base = require("@scure/base");
var import_eventemitter3 = __toESM(require("eventemitter3"));
var import_nostr_tools = require("nostr-tools");
var DEFAULT_RELAYS = [
  "wss://nos.lol",
  "wss://relay.nostr.band",
  "wss://relay.f7z.io",
  "wss://relay.damus.io",
  "wss://nostr.mom",
  "wss://no.str.cr"
];
var Zap = class extends import_eventemitter3.default {
  ndk;
  zappedEvent;
  zappedUser;
  constructor(args) {
    super();
    this.ndk = args.ndk;
    this.zappedEvent = args.zappedEvent;
    this.zappedUser = args.zappedUser || this.ndk.getUser({ hexpubkey: this.zappedEvent.pubkey });
  }
  async getZapEndpoint() {
    let lud06;
    let lud16;
    let zapEndpoint;
    let zapEndpointCallback;
    if (this.zappedEvent) {
      const zapTag = (await this.zappedEvent.getMatchingTags("zap"))[0];
      if (zapTag) {
        switch (zapTag[2]) {
          case "lud06":
            lud06 = zapTag[1];
            break;
          case "lud16":
            lud16 = zapTag[1];
            break;
          default:
            throw new Error(`Unknown zap tag ${zapTag}`);
        }
      }
    }
    if (this.zappedUser && !lud06 && !lud16) {
      if (!this.zappedUser.profile) {
        await this.zappedUser.fetchProfile();
      }
      lud06 = (this.zappedUser.profile || {}).lud06;
      lud16 = (this.zappedUser.profile || {}).lud16;
    }
    if (lud16) {
      const [name, domain] = lud16.split("@");
      zapEndpoint = `https://${domain}/.well-known/lnurlp/${name}`;
    } else if (lud06) {
      const { words } = import_base.bech32.decode(lud06, 1e3);
      const data = import_base.bech32.fromWords(words);
      const utf8Decoder = new TextDecoder("utf-8");
      zapEndpoint = utf8Decoder.decode(data);
    }
    if (!zapEndpoint) {
      throw new Error("No zap endpoint found");
    }
    const response = await fetch(zapEndpoint);
    const body = await response.json();
    if (body?.allowsNostr && (body?.nostrPubkey || body?.nostrPubKey)) {
      zapEndpointCallback = body.callback;
    }
    return zapEndpointCallback;
  }
  /**
   * Generates a kind:9734 zap request and returns the payment request
   * @param amount amount to zap in millisatoshis
   * @param comment optional comment to include in the zap request
   * @param extraTags optional extra tags to include in the zap request
   * @param relays optional relays to ask zapper to publish the zap to
   * @returns the payment request
   */
  async createZapRequest(amount, comment, extraTags, relays) {
    const zapEndpoint = await this.getZapEndpoint();
    if (!zapEndpoint) {
      throw new Error("No zap endpoint found");
    }
    if (!this.zappedEvent)
      throw new Error("No zapped event found");
    const zapRequest = import_nostr_tools.nip57.makeZapRequest({
      profile: this.zappedUser.hexpubkey(),
      // set the event to null since nostr-tools doesn't support nip-33 zaps
      event: null,
      amount,
      comment: comment || "",
      relays: relays ?? this.relays()
    });
    if (this.zappedEvent) {
      const tag = this.zappedEvent.tagReference();
      if (tag) {
        zapRequest.tags.push(tag);
      }
    }
    zapRequest.tags.push(["lnurl", zapEndpoint]);
    const zapRequestEvent = new NDKEvent(this.ndk, zapRequest);
    if (extraTags) {
      zapRequestEvent.tags = zapRequestEvent.tags.concat(extraTags);
    }
    await zapRequestEvent.sign();
    const zapRequestNostrEvent = await zapRequestEvent.toNostrEvent();
    const response = await fetch(
      `${zapEndpoint}?` + new URLSearchParams({
        amount: amount.toString(),
        nostr: JSON.stringify(zapRequestNostrEvent)
      })
    );
    const body = await response.json();
    return body.pr;
  }
  /**
   * @returns the relays to use for the zap request
   */
  relays() {
    let r = [];
    if (this.ndk?.pool?.relays) {
      r = this.ndk.pool.urls();
    }
    if (!r.length) {
      r = DEFAULT_RELAYS;
    }
    return r;
  }
};

// src/events/content-tagger.ts
var import_nostr_tools2 = require("nostr-tools");
function generateContentTags(content, tags = []) {
  const tagRegex = /(@|nostr:)(npub|nprofile|note|nevent)[a-zA-Z0-9]+/g;
  content = content.replace(tagRegex, (tag) => {
    try {
      const entity = tag.split(/(@|nostr:)/)[2];
      const { type, data } = import_nostr_tools2.nip19.decode(entity);
      let t;
      switch (type) {
        case "npub":
          t = ["p", data];
          break;
        case "nprofile":
          t = ["p", data.pubkey];
          break;
        case "nevent":
          t = ["e", data.id];
          break;
        case "note":
          t = ["e", data];
          break;
        default:
          return tag;
      }
      if (!tags.find((t2) => t2[0] === t[0] && t2[1] === t[1])) {
        tags.push(t);
      }
      return `nostr:${entity}`;
    } catch (error) {
      return tag;
    }
  });
  return { content, tags };
}

// src/events/kind.ts
function isReplaceable() {
  if (this.kind === void 0)
    throw new Error("Kind not set");
  return this.kind >= 1e4 && this.kind < 2e4;
}
function isParamReplaceable() {
  if (this.kind === void 0)
    throw new Error("Kind not set");
  return this.kind >= 3e4 && this.kind < 4e4;
}

// src/events/kinds/index.ts
var NDKKind = /* @__PURE__ */ ((NDKKind2) => {
  NDKKind2[NDKKind2["Metadata"] = 0] = "Metadata";
  NDKKind2[NDKKind2["Text"] = 1] = "Text";
  NDKKind2[NDKKind2["RecommendRelay"] = 2] = "RecommendRelay";
  NDKKind2[NDKKind2["Contacts"] = 3] = "Contacts";
  NDKKind2[NDKKind2["EncryptedDirectMessage"] = 4] = "EncryptedDirectMessage";
  NDKKind2[NDKKind2["EventDeletion"] = 5] = "EventDeletion";
  NDKKind2[NDKKind2["Repost"] = 6] = "Repost";
  NDKKind2[NDKKind2["Reaction"] = 7] = "Reaction";
  NDKKind2[NDKKind2["BadgeAward"] = 8] = "BadgeAward";
  NDKKind2[NDKKind2["GenericRepost"] = 16] = "GenericRepost";
  NDKKind2[NDKKind2["ChannelCreation"] = 40] = "ChannelCreation";
  NDKKind2[NDKKind2["ChannelMetadata"] = 41] = "ChannelMetadata";
  NDKKind2[NDKKind2["ChannelMessage"] = 42] = "ChannelMessage";
  NDKKind2[NDKKind2["ChannelHideMessage"] = 43] = "ChannelHideMessage";
  NDKKind2[NDKKind2["ChannelMuteUser"] = 44] = "ChannelMuteUser";
  NDKKind2[NDKKind2["Report"] = 1984] = "Report";
  NDKKind2[NDKKind2["ZapRequest"] = 9734] = "ZapRequest";
  NDKKind2[NDKKind2["Zap"] = 9735] = "Zap";
  NDKKind2[NDKKind2["MuteList"] = 1e4] = "MuteList";
  NDKKind2[NDKKind2["PinList"] = 10001] = "PinList";
  NDKKind2[NDKKind2["RelayList"] = 10002] = "RelayList";
  NDKKind2[NDKKind2["ClientAuth"] = 22242] = "ClientAuth";
  NDKKind2[NDKKind2["NostrConnect"] = 24133] = "NostrConnect";
  NDKKind2[NDKKind2["CategorizedPeopleList"] = 3e4] = "CategorizedPeopleList";
  NDKKind2[NDKKind2["CategorizedBookmarkList"] = 30001] = "CategorizedBookmarkList";
  NDKKind2[NDKKind2["CategorizedRelayList"] = 30022] = "CategorizedRelayList";
  NDKKind2[NDKKind2["ProfileBadge"] = 30008] = "ProfileBadge";
  NDKKind2[NDKKind2["BadgeDefinition"] = 30009] = "BadgeDefinition";
  NDKKind2[NDKKind2["Article"] = 30023] = "Article";
  NDKKind2[NDKKind2["AppSpecificData"] = 30078] = "AppSpecificData";
  return NDKKind2;
})(NDKKind || {});

// src/user/index.ts
var import_nostr_tools4 = require("nostr-tools");

// src/user/follows.ts
var import_nostr_tools3 = require("nostr-tools");
async function follows() {
  if (!this.ndk)
    throw new Error("NDK not set");
  const contactListEvents = await this.ndk.fetchEvents({
    kinds: [3],
    authors: [this.hexpubkey()]
  });
  if (contactListEvents) {
    const npubs = /* @__PURE__ */ new Set();
    contactListEvents.forEach((event) => {
      event.tags.forEach((tag) => {
        if (tag[0] === "p") {
          try {
            const npub = import_nostr_tools3.nip19.npubEncode(tag[1]);
            npubs.add(npub);
          } catch (e) {
          }
        }
      });
    });
    return [...npubs].reduce((acc, npub) => {
      const user = new NDKUser({ npub });
      user.ndk = this.ndk;
      acc.add(user);
      return acc;
    }, /* @__PURE__ */ new Set());
  }
  return /* @__PURE__ */ new Set();
}

// src/user/profile.ts
function mergeEvent(event, profile) {
  const payload = JSON.parse(event.content);
  Object.keys(payload).forEach((key) => {
    switch (key) {
      case "name":
        profile.name = payload.name;
        break;
      case "display_name":
      case "displayName":
        profile.displayName = payload.displayName || payload.display_name;
        break;
      case "image":
      case "picture":
        profile.image = payload.image || payload.picture;
        break;
      case "banner":
        profile.banner = payload.banner;
        break;
      case "bio":
        profile.bio = payload.bio;
        break;
      case "nip05":
        profile.nip05 = payload.nip05;
        break;
      case "lud06":
        profile.lud06 = payload.lud06;
        break;
      case "lud16":
        profile.lud16 = payload.lud16;
        break;
      case "about":
        profile.about = payload.about;
        break;
      case "zapService":
        profile.zapService = payload.zapService;
        break;
      case "website":
        profile.website = payload.website;
        break;
      default:
        profile[key] = payload[key];
        break;
    }
  });
  return profile;
}

// src/user/index.ts
var NDKUser = class {
  ndk;
  profile;
  npub = "";
  relayUrls = [];
  constructor(opts) {
    if (opts.npub)
      this.npub = opts.npub;
    if (opts.hexpubkey) {
      this.npub = import_nostr_tools4.nip19.npubEncode(opts.hexpubkey);
    }
    if (opts.relayUrls) {
      this.relayUrls = opts.relayUrls;
    }
  }
  /**
   * Instantiate an NDKUser from a NIP-05 string
   * @param nip05Id {string} The user's NIP-05
   * @returns {NDKUser | undefined} An NDKUser if one is found for the given NIP-05, undefined otherwise.
   */
  static async fromNip05(nip05Id) {
    const profile = await import_nostr_tools4.nip05.queryProfile(nip05Id);
    if (profile) {
      return new NDKUser({
        hexpubkey: profile.pubkey,
        relayUrls: profile.relays
      });
    }
  }
  /**
   * Get the hexpubkey for a user
   * @returns {string} The user's hexpubkey
   */
  hexpubkey() {
    return import_nostr_tools4.nip19.decode(this.npub).data;
  }
  /**
   * Fetch a user's kind 0 metadata events and merge the events in a single up-to-date profile
   * @param opts {NDKFilterOptions} A set of NDKFilterOptions
   * @returns {Promise<Set<Event>>} A set of all NDKEvents events returned for the given user
   */
  async fetchProfile(opts) {
    if (!this.ndk)
      throw new Error("NDK not set");
    if (!this.profile)
      this.profile = {};
    const setMetadataEvents = await this.ndk.fetchEvents(
      {
        kinds: [0],
        authors: [this.hexpubkey()]
      },
      opts
    );
    if (setMetadataEvents) {
      const sortedSetMetadataEvents = Array.from(setMetadataEvents).sort(
        (a, b) => a.created_at - b.created_at
      );
      sortedSetMetadataEvents.forEach((event) => {
        try {
          this.profile = mergeEvent(event, this.profile);
        } catch (e) {
        }
      });
    }
    return setMetadataEvents;
  }
  /**
   * Returns a set of users that this user follows.
   */
  follows = follows.bind(this);
  /**
   * Returns a set of relay list events for a user.
   * @returns {Promise<Set<Event>>} A set of NDKEvents returned for the given user.
   */
  async relayList() {
    if (!this.ndk)
      throw new Error("NDK not set");
    const relayListEvents = await this.ndk.fetchEvents({
      kinds: [10002],
      authors: [this.hexpubkey()]
    });
    if (relayListEvents) {
      return relayListEvents;
    }
    return /* @__PURE__ */ new Set();
  }
  /**
   * Get the tag that can be used to reference this user in an event
   * @returns {NDKTag} an NDKTag
   */
  tagReference() {
    return ["p", this.hexpubkey()];
  }
  /**
   * Publishes the current profile.
   */
  async publish() {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    this.ndk.assertSigner();
    const event = new NDKEvent(this.ndk, {
      kind: 0,
      content: JSON.stringify(this.profile)
    });
    await event.publish();
  }
  /**
   * Add a follow to this user's contact list
   *
   * @param newFollow {NDKUser} The user to follow
   * @param currentFollowList {Set<NDKUser>} The current follow list
   * @returns {Promise<boolean>} True if the follow was added, false if the follow already exists
   */
  async follow(newFollow, currentFollowList) {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    this.ndk.assertSigner();
    if (!currentFollowList) {
      currentFollowList = await this.follows();
    }
    if (currentFollowList.has(newFollow)) {
      return false;
    }
    currentFollowList.add(newFollow);
    const event = new NDKEvent(this.ndk, { kind: 3 /* Contacts */ });
    for (const follow of currentFollowList) {
      event.tag(follow);
    }
    await event.publish();
    return true;
  }
};

// src/events/nip04.ts
async function encrypt(recipient, signer) {
  if (!signer) {
    if (!this.ndk) {
      throw new Error("No signer available");
    }
    await this.ndk.assertSigner();
    signer = this.ndk.signer;
  }
  if (!recipient) {
    const pTags = this.getMatchingTags("p");
    if (pTags.length !== 1) {
      throw new Error("No recipient could be determined and no explicit recipient was provided");
    }
    recipient = new NDKUser({ hexpubkey: pTags[0][1] });
    recipient.ndk = this.ndk;
  }
  this.content = await signer.encrypt(recipient, this.content);
}
async function decrypt(sender, signer) {
  if (!signer) {
    if (!this.ndk) {
      throw new Error("No signer available");
    }
    await this.ndk.assertSigner();
    signer = this.ndk.signer;
  }
  if (!sender) {
    sender = this.author;
  }
  this.content = await signer.decrypt(sender, this.content);
}

// src/events/nip19.ts
var import_nostr_tools5 = require("nostr-tools");
function encode() {
  if (this.isParamReplaceable()) {
    return import_nostr_tools5.nip19.naddrEncode({
      kind: this.kind,
      pubkey: this.pubkey,
      identifier: this.replaceableDTag()
    });
  } else {
    return import_nostr_tools5.nip19.noteEncode(this.tagId());
  }
}

// src/events/repost.ts
async function repost(publish = true, signer) {
  if (!signer) {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    this.ndk.assertSigner();
    signer = this.ndk.signer;
  }
  if (!signer) {
    throw new Error("No signer available");
  }
  const user = await signer.user();
  const e = new NDKEvent(this.ndk, {
    kind: getKind(this),
    content: "",
    pubkey: user.hexpubkey()
  });
  e.tag(this);
  if (e.kind === 16 /* GenericRepost */) {
    e.tags.push(["k", `${this.kind}`]);
  }
  await e.sign(signer);
  if (publish)
    await e.publish();
  return e;
}
function getKind(event) {
  if (event.kind === 1) {
    return 6 /* Repost */;
  }
  return 16 /* GenericRepost */;
}

// src/events/index.ts
var NDKEvent = class extends import_eventemitter32.default {
  ndk;
  created_at;
  content = "";
  tags = [];
  kind;
  id = "";
  sig;
  pubkey = "";
  /**
   * The relay that this event was first received from.
   */
  relay;
  constructor(ndk, event) {
    super();
    this.ndk = ndk;
    this.created_at = event?.created_at;
    this.content = event?.content || "";
    this.tags = event?.tags || [];
    this.id = event?.id || "";
    this.sig = event?.sig;
    this.pubkey = event?.pubkey || "";
    this.kind = event?.kind;
  }
  /**
   * Returns the event as is.
   */
  rawEvent() {
    return {
      created_at: this.created_at,
      content: this.content,
      tags: this.tags,
      kind: this.kind,
      pubkey: this.pubkey,
      id: this.id,
      sig: this.sig
    };
  }
  set author(user) {
    this.pubkey = user.hexpubkey();
  }
  /**
   * Returns an NDKUser for the author of the event.
   */
  get author() {
    const user = new NDKUser({ hexpubkey: this.pubkey });
    user.ndk = this.ndk;
    return user;
  }
  tag(userOrEvent, marker) {
    const tag = userOrEvent.tagReference();
    if (marker)
      tag.push(marker);
    this.tags.push(tag);
    if (userOrEvent instanceof NDKEvent) {
      const tagEventAuthor = userOrEvent.author;
      if (tagEventAuthor && this.pubkey !== tagEventAuthor.hexpubkey()) {
        this.tag(tagEventAuthor);
      }
      for (const pTag of userOrEvent.getMatchingTags("p")) {
        if (pTag[1] === this.pubkey)
          continue;
        if (this.tags.find((t) => t[0] === "p" && t[1] === pTag[1]))
          continue;
        this.tags.push(["p", pTag[1]]);
      }
    }
  }
  /**
   * Return a NostrEvent object, trying to fill in missing fields
   * when possible, adding tags when necessary.
   * @param pubkey {string} The pubkey of the user who the event belongs to.
   * @returns {Promise<NostrEvent>} A promise that resolves to a NostrEvent.
   */
  async toNostrEvent(pubkey) {
    if (!pubkey && this.pubkey === "") {
      const user = await this.ndk?.signer?.user();
      this.pubkey = user?.hexpubkey() || "";
    }
    if (!this.created_at)
      this.created_at = Math.floor(Date.now() / 1e3);
    const nostrEvent = this.rawEvent();
    const { content, tags } = this.generateTags();
    nostrEvent.content = content || "";
    nostrEvent.tags = tags;
    try {
      this.id = (0, import_nostr_tools6.getEventHash)(nostrEvent);
    } catch (e) {
    }
    if (this.id)
      nostrEvent.id = this.id;
    if (this.sig)
      nostrEvent.sig = this.sig;
    return nostrEvent;
  }
  isReplaceable = isReplaceable.bind(this);
  isParamReplaceable = isParamReplaceable.bind(this);
  encode = encode.bind(this);
  encrypt = encrypt.bind(this);
  decrypt = decrypt.bind(this);
  /**
   * Get all tags with the given name
   * @param tagName {string} The name of the tag to search for
   * @returns {NDKTag[]} An array of the matching tags
   */
  getMatchingTags(tagName) {
    return this.tags.filter((tag) => tag[0] === tagName);
  }
  /**
   * Get the first tag with the given name
   * @param tagName Tag name to search for
   * @returns The value of the first tag with the given name, or undefined if no such tag exists
   */
  tagValue(tagName) {
    const tags = this.getMatchingTags(tagName);
    if (tags.length === 0)
      return void 0;
    return tags[0][1];
  }
  /**
   * Remove all tags with the given name (e.g. "d", "a", "p")
   * @param tagName Tag name to search for and remove
   * @returns {void}
   */
  removeTag(tagName) {
    this.tags = this.tags.filter((tag) => tag[0] !== tagName);
  }
  /**
   * Sign the event if a signer is present.
   *
   * It will generate tags.
   * Repleacable events will have their created_at field set to the current time.
   * @param signer {NDKSigner} The NDKSigner to use to sign the event
   * @returns {Promise<string>} A Promise that resolves to the signature of the signed event.
   */
  async sign(signer) {
    if (!signer) {
      this.ndk?.assertSigner();
      signer = this.ndk.signer;
    }
    await this.generateTags();
    if (this.isReplaceable()) {
      this.created_at = Math.floor(Date.now() / 1e3);
    }
    const nostrEvent = await this.toNostrEvent();
    this.sig = await signer.sign(nostrEvent);
    return this.sig;
  }
  /**
   * Attempt to sign and then publish an NDKEvent to a given relaySet.
   * If no relaySet is provided, the relaySet will be calculated by NDK.
   * @param relaySet {NDKRelaySet} The relaySet to publish the even to.
   * @returns A promise that resolves to the relays the event was published to.
   */
  async publish(relaySet, timeoutMs) {
    if (!this.sig)
      await this.sign();
    if (!this.ndk)
      throw new Error("NDKEvent must be associated with an NDK instance to publish");
    return this.ndk.publish(this, relaySet, timeoutMs);
  }
  /**
   * Generates tags for users, notes, and other events tagged in content.
   * Will also generate random "d" tag for parameterized replaceable events where needed.
   * @returns {ContentTag} The tags and content of the event.
   */
  generateTags() {
    let tags = [];
    const g = generateContentTags(this.content, this.tags);
    const content = g.content;
    tags = g.tags;
    if (this.kind && this.kind >= 3e4 && this.kind <= 4e4) {
      const dTag = this.getMatchingTags("d")[0];
      if (!dTag) {
        const str = [...Array(16)].map(() => Math.random().toString(36)[2]).join("");
        tags.push(["d", str]);
      }
    }
    return { content: content || "", tags };
  }
  /**
   * Returns the "d" tag of a parameterized replaceable event or throws an error if the event isn't
   * a parameterized replaceable event.
   * @returns {string} the "d" tag of the event.
   */
  replaceableDTag() {
    if (this.kind && this.kind >= 3e4 && this.kind <= 4e4) {
      const dTag = this.getMatchingTags("d")[0];
      const dTagId = dTag ? dTag[1] : "";
      return dTagId;
    }
    throw new Error("Event is not a parameterized replaceable event");
  }
  /**
   * Returns the id of the event or, if it's a parameterized event, the generated id of the event using "d" tag, pubkey, and kind.
   * @returns {string} The id
   */
  tagId() {
    if (this.kind && this.kind >= 3e4 && this.kind <= 4e4) {
      const dTagId = this.replaceableDTag();
      return `${this.kind}:${this.pubkey}:${dTagId}`;
    }
    return this.id;
  }
  /**
   * Get the tag that can be used to reference this event from another event
   * @example
   *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ ["d", "d-code"] ] });
   *     event.tagReference(); // ["a", "30000:pubkey:d-code"]
   *
   *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: "eventid" });
   *     event.tagReference(); // ["e", "eventid"]
   * @returns {NDKTag} The NDKTag object referencing this event
   */
  tagReference() {
    if (this.isParamReplaceable()) {
      return ["a", this.tagId()];
    }
    return ["e", this.tagId()];
  }
  /**
   * Provides the filter that will return matching events for this event.
   *
   * @example
   *    event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ ["d", "d-code"] ] });
   *    event.filter(); // { "#a": ["30000:pubkey:d-code"] }
   * @example
   *    event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: "eventid" });
   *    event.filter(); // { "#e": ["eventid"] }
   *
   * @returns The filter that will return matching events for this event
   */
  filter() {
    if (this.isParamReplaceable()) {
      return { "#a": [this.tagId()] };
    } else {
      return { "#e": [this.tagId()] };
    }
  }
  /**
   * Create a zap request for an existing event
   *
   * @param amount The amount to zap in millisatoshis
   * @param comment A comment to add to the zap request
   * @param extraTags Extra tags to add to the zap request
   */
  async zap(amount, comment, extraTags) {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    this.ndk.assertSigner();
    const zap = new Zap({
      ndk: this.ndk,
      zappedEvent: this
    });
    const paymentRequest = await zap.createZapRequest(amount, comment, extraTags);
    return paymentRequest;
  }
  /**
   * Generates a deletion event of the current event
   *
   * @param reason The reason for the deletion
   * @returns The deletion event
   */
  async delete(reason) {
    if (!this.ndk)
      throw new Error("No NDK instance found");
    this.ndk.assertSigner();
    const e = new NDKEvent(this.ndk, {
      kind: 5 /* EventDeletion */,
      content: reason || ""
    });
    e.tag(this);
    await e.publish();
    return e;
  }
  /**
   * NIP-18 reposting event.
   *
   * @param publish Whether to publish the reposted event automatically
   * @param signer The signer to use for signing the reposted event
   * @returns The reposted event
   *
   * @function
   */
  repost = repost.bind(this);
};

// src/relay/pool/index.ts
var import_eventemitter34 = __toESM(require("eventemitter3"));

// src/relay/index.ts
var import_eventemitter33 = __toESM(require("eventemitter3"));
var import_nostr_tools7 = require("nostr-tools");
var import_websocket_polyfill = require("websocket-polyfill");
var import_debug = __toESM(require("debug"));
var NDKRelayStatus = /* @__PURE__ */ ((NDKRelayStatus2) => {
  NDKRelayStatus2[NDKRelayStatus2["CONNECTING"] = 0] = "CONNECTING";
  NDKRelayStatus2[NDKRelayStatus2["CONNECTED"] = 1] = "CONNECTED";
  NDKRelayStatus2[NDKRelayStatus2["DISCONNECTING"] = 2] = "DISCONNECTING";
  NDKRelayStatus2[NDKRelayStatus2["DISCONNECTED"] = 3] = "DISCONNECTED";
  NDKRelayStatus2[NDKRelayStatus2["RECONNECTING"] = 4] = "RECONNECTING";
  NDKRelayStatus2[NDKRelayStatus2["FLAPPING"] = 5] = "FLAPPING";
  return NDKRelayStatus2;
})(NDKRelayStatus || {});
var NDKRelay2 = class extends import_eventemitter33.default {
  url;
  scores;
  relay;
  _status;
  connectedAt;
  _connectionStats = { attempts: 0, success: 0, durations: [] };
  complaining = false;
  debug;
  /**
   * Active subscriptions this relay is connected to
   */
  activeSubscriptions = /* @__PURE__ */ new Set();
  constructor(url) {
    super();
    this.url = url;
    this.relay = (0, import_nostr_tools7.relayInit)(url);
    this.scores = /* @__PURE__ */ new Map();
    this._status = 3 /* DISCONNECTED */;
    this.debug = (0, import_debug.default)(`ndk:relay:${url}`);
    this.relay.on("connect", () => {
      this.updateConnectionStats.connected();
      this._status = 1 /* CONNECTED */;
      this.emit("connect");
    });
    this.relay.on("disconnect", () => {
      this.updateConnectionStats.disconnected();
      if (this._status === 1 /* CONNECTED */) {
        this._status = 3 /* DISCONNECTED */;
        this.handleReconnection();
      }
      this.emit("disconnect");
    });
    this.relay.on("notice", (notice) => this.handleNotice(notice));
  }
  /**
   * Evaluates the connection stats to determine if the relay is flapping.
   */
  isFlapping() {
    const durations = this._connectionStats.durations;
    if (durations.length < 10)
      return false;
    const sum = durations.reduce((a, b) => a + b, 0);
    const avg = sum / durations.length;
    const variance = durations.map((x) => Math.pow(x - avg, 2)).reduce((a, b) => a + b, 0) / durations.length;
    const stdDev = Math.sqrt(variance);
    const isFlapping = stdDev < 1e3;
    return isFlapping;
  }
  /**
   * Called when the relay is unexpectedly disconnected.
   */
  handleReconnection() {
    if (this.isFlapping()) {
      this.emit("flapping", this, this._connectionStats);
      this._status = 5 /* FLAPPING */;
    }
    if (this.connectedAt && Date.now() - this.connectedAt < 5e3) {
      setTimeout(() => this.connect(), 6e4);
    } else {
      this.connect();
    }
  }
  get status() {
    return this._status;
  }
  /**
   * Connects to the relay.
   */
  async connect() {
    try {
      this.updateConnectionStats.attempt();
      this._status = 0 /* CONNECTING */;
      await this.relay.connect();
    } catch (e) {
      this.debug("Failed to connect", e);
      this._status = 3 /* DISCONNECTED */;
      throw e;
    }
  }
  /**
   * Disconnects from the relay.
   */
  disconnect() {
    this._status = 2 /* DISCONNECTING */;
    this.relay.close();
  }
  async handleNotice(notice) {
    if (notice.includes("oo many") || notice.includes("aximum")) {
      this.disconnect();
      setTimeout(() => this.connect(), 2e3);
      this.debug(this.relay.url, "Relay complaining?", notice);
    }
    this.emit("notice", this, notice);
  }
  /**
   * Subscribes to a subscription.
   */
  subscribe(subscription) {
    const { filter } = subscription;
    const sub = this.relay.sub([filter], {
      id: subscription.subId
    });
    this.debug(`Subscribed to ${JSON.stringify(filter)}`);
    sub.on("event", (event) => {
      const e = new NDKEvent(void 0, event);
      e.relay = this;
      subscription.eventReceived(e, this);
    });
    sub.on("eose", () => {
      subscription.eoseReceived(this);
    });
    const unsub = sub.unsub;
    sub.unsub = () => {
      this.debug(`Unsubscribing from ${JSON.stringify(filter)}`);
      this.activeSubscriptions.delete(subscription);
      unsub();
    };
    this.activeSubscriptions.add(subscription);
    subscription.on("close", () => {
      this.activeSubscriptions.delete(subscription);
    });
    return sub;
  }
  /**
   * Publishes an event to the relay with an optional timeout.
   *
   * If the relay is not connected, the event will be published when the relay connects,
   * unless the timeout is reached before the relay connects.
   *
   * @param event The event to publish
   * @param timeoutMs The timeout for the publish operation in milliseconds
   * @returns A promise that resolves when the event has been published or rejects if the operation times out
   */
  async publish(event, timeoutMs = 2500) {
    if (this.status === 1 /* CONNECTED */) {
      return this.publishEvent(event, timeoutMs);
    } else {
      this.once("connect", () => {
        this.publishEvent(event, timeoutMs);
      });
      return true;
    }
  }
  async publishEvent(event, timeoutMs) {
    const nostrEvent = await event.toNostrEvent();
    const a = this.relay.publish(nostrEvent);
    let publishTimeout;
    const publishPromise = new Promise((resolve, reject) => {
      a.on("failed", (err) => {
        clearTimeout(publishTimeout);
        this.debug("Publish failed", err, event.id);
        this.emit("publish:failed", event, err);
        reject(err);
      });
      a.on("ok", () => {
        clearTimeout(publishTimeout);
        this.emit("published", event);
        resolve(true);
      });
    });
    if (!timeoutMs) {
      return publishPromise;
    }
    const timeoutPromise = new Promise((_, reject) => {
      publishTimeout = setTimeout(() => {
        this.debug("Publish timed out", event.rawEvent());
        this.emit("publish:failed", event, "Timeout");
        reject(new Error("Publish operation timed out"));
      }, timeoutMs);
    });
    return Promise.race([publishPromise, timeoutPromise]);
  }
  /**
   * Called when this relay has responded with an event but
   * wasn't the fastest one.
   * @param timeDiffInMs The time difference in ms between the fastest and this relay in milliseconds
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  scoreSlowerEvent(timeDiffInMs) {
  }
  /**
   * Utility functions to update the connection stats.
   */
  updateConnectionStats = {
    connected: () => {
      this._connectionStats.success++;
      this._connectionStats.connectedAt = Date.now();
    },
    disconnected: () => {
      if (this._connectionStats.connectedAt) {
        this._connectionStats.durations.push(
          Date.now() - this._connectionStats.connectedAt
        );
        if (this._connectionStats.durations.length > 100) {
          this._connectionStats.durations.shift();
        }
      }
      this._connectionStats.connectedAt = void 0;
    },
    attempt: () => {
      this._connectionStats.attempts++;
    }
  };
  /**
   * Returns the connection stats.
   */
  get connectionStats() {
    return this._connectionStats;
  }
  tagReference(marker) {
    const tag = ["r", this.relay.url];
    if (marker) {
      tag.push(marker);
    }
    return tag;
  }
};

// src/relay/pool/index.ts
var NDKPool = class extends import_eventemitter34.default {
  relays = /* @__PURE__ */ new Map();
  debug;
  constructor(relayUrls = [], ndk) {
    super();
    this.debug = ndk.debug.extend("pool");
    for (const relayUrl of relayUrls) {
      const relay = new NDKRelay2(relayUrl);
      relay.on("notice", (relay2, notice) => this.emit("notice", relay2, notice));
      relay.on("connect", () => this.handleRelayConnect(relayUrl));
      relay.on("disconnect", () => this.emit("relay:disconnect", relay));
      relay.on("flapping", () => this.handleFlapping(relay));
      this.relays.set(relayUrl, relay);
    }
  }
  handleRelayConnect(relayUrl) {
    this.debug(`Relay ${relayUrl} connected`);
    this.emit("relay:connect", this.relays.get(relayUrl));
    if (this.stats().connected === this.relays.size) {
      this.emit("connect");
    }
  }
  /**
   * Attempts to establish a connection to each relay in the pool.
   *
   * @async
   * @param {number} [timeoutMs] - Optional timeout in milliseconds for each connection attempt.
   * @returns {Promise<void>} A promise that resolves when all connection attempts have completed.
   * @throws {Error} If any of the connection attempts result in an error or timeout.
   */
  async connect(timeoutMs) {
    const promises = [];
    this.debug(
      `Connecting to ${this.relays.size} relays${timeoutMs ? `, timeout ${timeoutMs}...` : ""}`
    );
    for (const relay of this.relays.values()) {
      if (timeoutMs) {
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(`Timed out after ${timeoutMs}ms`), timeoutMs);
        });
        promises.push(
          Promise.race([relay.connect(), timeoutPromise]).catch((e) => {
            this.debug(`Failed to connect to relay ${relay.url}: ${e}`);
          })
        );
      } else {
        promises.push(relay.connect());
      }
    }
    if (timeoutMs) {
      setTimeout(() => {
        const allConnected = this.stats().connected === this.relays.size;
        const someConnected = this.stats().connected > 0;
        if (!allConnected && someConnected) {
          this.emit("connect");
        }
      }, timeoutMs);
    }
    await Promise.all(promises);
  }
  handleFlapping(relay) {
    this.debug(`Relay ${relay.url} is flapping`);
    this.relays.delete(relay.url);
    this.emit("flapping", relay);
  }
  size() {
    return this.relays.size;
  }
  /**
   * Returns the status of each relay in the pool.
   * @returns {NDKPoolStats} An object containing the number of relays in each status.
   */
  stats() {
    const stats = {
      total: 0,
      connected: 0,
      disconnected: 0,
      connecting: 0
    };
    for (const relay of this.relays.values()) {
      stats.total++;
      if (relay.status === 1 /* CONNECTED */) {
        stats.connected++;
      } else if (relay.status === 3 /* DISCONNECTED */) {
        stats.disconnected++;
      } else if (relay.status === 0 /* CONNECTING */) {
        stats.connecting++;
      }
    }
    return stats;
  }
  /**
   * Get a list of all relay urls in the pool.
   */
  urls() {
    return Array.from(this.relays.keys());
  }
};

// src/relay/sets/index.ts
var import_sha256 = require("@noble/hashes/sha256");
var import_utils2 = require("@noble/hashes/utils");

// src/subscription/index.ts
var import_eventemitter35 = __toESM(require("eventemitter3"));
var import_nostr_tools8 = require("nostr-tools");

// src/subscription/utils.ts
function queryFullyFilled(subscription) {
  if (filterIncludesIds(subscription.filter)) {
    if (resultHasAllRequestedIds(subscription)) {
      return true;
    }
  }
  return false;
}
function filterIncludesIds(filter) {
  return !!filter["ids"];
}
function resultHasAllRequestedIds(subscription) {
  const ids = subscription.filter["ids"];
  return !!ids && ids.length === subscription.eventFirstSeen.size;
}

// src/subscription/index.ts
var NDKSubscriptionCacheUsage = /* @__PURE__ */ ((NDKSubscriptionCacheUsage2) => {
  NDKSubscriptionCacheUsage2["ONLY_CACHE"] = "ONLY_CACHE";
  NDKSubscriptionCacheUsage2["CACHE_FIRST"] = "CACHE_FIRST";
  NDKSubscriptionCacheUsage2["PARALLEL"] = "PARALLEL";
  NDKSubscriptionCacheUsage2["ONLY_RELAY"] = "ONLY_RELAY";
  return NDKSubscriptionCacheUsage2;
})(NDKSubscriptionCacheUsage || {});
var defaultOpts = {
  closeOnEose: true,
  cacheUsage: "CACHE_FIRST" /* CACHE_FIRST */,
  groupable: true,
  groupableDelay: 100
};
var NDKSubscription = class extends import_eventemitter35.default {
  subId;
  filter;
  opts;
  relaySet;
  ndk;
  relaySubscriptions;
  debug;
  /**
   * Events that have been seen by the subscription, with the time they were first seen.
   */
  eventFirstSeen = /* @__PURE__ */ new Map();
  /**
   * Relays that have sent an EOSE.
   */
  eosesSeen = /* @__PURE__ */ new Set();
  /**
   * Events that have been seen by the subscription per relay.
   */
  eventsPerRelay = /* @__PURE__ */ new Map();
  constructor(ndk, filter, opts, relaySet, subId) {
    super();
    this.ndk = ndk;
    this.opts = { ...defaultOpts, ...opts || {} };
    this.subId = subId || opts?.subId || generateFilterId(filter);
    this.filter = filter;
    this.relaySet = relaySet;
    this.relaySubscriptions = /* @__PURE__ */ new Map();
    this.debug = ndk.debug.extend(`subscription:${this.subId}`);
    if (this.opts.cacheUsage === "ONLY_CACHE" /* ONLY_CACHE */ && !this.opts.closeOnEose) {
      throw new Error("Cannot use cache-only options with a persistent subscription");
    }
  }
  /**
   * Calculates the groupable ID for this subscription.
   *
   * @returns The groupable ID, or null if the subscription is not groupable.
   */
  groupableId() {
    if (!this.opts?.groupable) {
      return null;
    }
    const hasKind = (this.filter.kinds?.length || 0) > 0;
    const noTimeConstraints = !this.filter.since && !this.filter.until;
    const noLimit = !this.filter.limit;
    if (hasKind && noTimeConstraints && noLimit) {
      let id = this.filter.kinds.join(",");
      const keys = Object.keys(this.filter || {}).sort().join("-");
      id += `-${keys}`;
      return id;
    }
    return null;
  }
  shouldQueryCache() {
    return this.opts?.cacheUsage !== "ONLY_RELAY" /* ONLY_RELAY */;
  }
  shouldQueryRelays() {
    return this.opts?.cacheUsage !== "ONLY_CACHE" /* ONLY_CACHE */;
  }
  shouldWaitForCache() {
    return (
      // Must want to close on EOSE; subscriptions
      // that want to receive further updates must
      // always hit the relay
      this.opts.closeOnEose && // Cache adapter must claim to be fast
      !!this.ndk.cacheAdapter?.locking && // If we don't have to query relays there's no need
      // to wait for the cache
      this.shouldQueryRelays() && // If explicitly told to run in parallel, then
      // we should not wait for the cache
      this.opts.cacheUsage !== "PARALLEL" /* PARALLEL */
    );
  }
  /**
   * Start the subscription. This is the main method that should be called
   * after creating a subscription.
   */
  async start() {
    let cachePromise;
    if (this.shouldQueryCache()) {
      cachePromise = this.startWithCache();
      if (this.shouldWaitForCache()) {
        await cachePromise;
        if (queryFullyFilled(this)) {
          this.debug("cache hit, fully filled: skipping relay query");
          this.emit("eose", this);
          return;
        }
      }
    }
    if (this.shouldQueryRelays()) {
      this.startWithRelaySet();
    }
    return;
  }
  stop() {
    this.relaySubscriptions.forEach((sub) => sub.unsub());
    this.relaySubscriptions.clear();
    this.emit("close", this);
  }
  async startWithCache() {
    if (this.ndk.cacheAdapter?.query) {
      const promise = this.ndk.cacheAdapter.query(this);
      if (this.ndk.cacheAdapter.locking) {
        await promise;
      }
    }
  }
  startWithRelaySet() {
    if (!this.relaySet) {
      this.relaySet = calculateRelaySetFromFilter(this.ndk, this.filter);
    }
    if (this.relaySet) {
      this.relaySet.subscribe(this);
    }
  }
  // EVENT handling
  /**
   * Called when an event is received from a relay or the cache
   * @param event
   * @param relay
   * @param fromCache Whether the event was received from the cache
   */
  eventReceived(event, relay, fromCache = false) {
    if (!fromCache && relay) {
      let events = this.eventsPerRelay.get(relay);
      if (!events) {
        events = /* @__PURE__ */ new Set();
        this.eventsPerRelay.set(relay, events);
      }
      events.add(event.id);
      const eventAlreadySeen = this.eventFirstSeen.has(event.id);
      if (eventAlreadySeen) {
        const timeSinceFirstSeen = Date.now() - (this.eventFirstSeen.get(event.id) || 0);
        relay.scoreSlowerEvent(timeSinceFirstSeen);
        this.emit("event:dup", event, relay, timeSinceFirstSeen, this);
        return;
      }
      if (this.ndk.cacheAdapter) {
        this.ndk.cacheAdapter.setEvent(event, this.filter);
      }
      this.eventFirstSeen.set(`${event.id}`, Date.now());
    } else {
      this.eventFirstSeen.set(`${event.id}`, 0);
    }
    this.emit("event", event, relay, this);
  }
  // EOSE handling
  eoseTimeout;
  eoseReceived(relay) {
    if (this.opts?.closeOnEose) {
      this.relaySubscriptions.get(relay)?.unsub();
      this.relaySubscriptions.delete(relay);
      if (this.relaySubscriptions.size === 0) {
        this.emit("close", this);
      }
    }
    this.eosesSeen.add(relay);
    const hasSeenAllEoses = this.eosesSeen.size === this.relaySet?.size();
    if (hasSeenAllEoses) {
      this.emit("eose");
    } else {
      if (this.eoseTimeout) {
        clearTimeout(this.eoseTimeout);
      }
      this.eoseTimeout = setTimeout(() => {
        this.emit("eose");
      }, 500);
    }
  }
};
var NDKSubscriptionGroup = class extends NDKSubscription {
  subscriptions;
  constructor(ndk, subscriptions) {
    const debug4 = ndk.debug.extend("subscription-group");
    const filters = mergeFilters(subscriptions.map((s) => s.filter));
    super(
      ndk,
      filters,
      subscriptions[0].opts,
      // TODO: This should be merged
      subscriptions[0].relaySet
      // TODO: This should be merged
    );
    this.subscriptions = subscriptions;
    debug4("merged filters", {
      count: subscriptions.length,
      mergedFilters: this.filter
    });
    this.on("event", this.forwardEvent);
    this.on("event:dup", this.forwardEventDup);
    this.on("eose", this.forwardEose);
    this.on("close", this.forwardClose);
  }
  isEventForSubscription(event, subscription) {
    const { filter } = subscription;
    if (!filter)
      return false;
    return (0, import_nostr_tools8.matchFilter)(filter, event.rawEvent());
  }
  forwardEvent(event, relay) {
    for (const subscription of this.subscriptions) {
      if (!this.isEventForSubscription(event, subscription)) {
        continue;
      }
      subscription.emit("event", event, relay, subscription);
    }
  }
  forwardEventDup(event, relay, timeSinceFirstSeen) {
    for (const subscription of this.subscriptions) {
      if (!this.isEventForSubscription(event, subscription)) {
        continue;
      }
      subscription.emit("event:dup", event, relay, timeSinceFirstSeen, subscription);
    }
  }
  forwardEose() {
    for (const subscription of this.subscriptions) {
      subscription.emit("eose", subscription);
    }
  }
  forwardClose() {
    for (const subscription of this.subscriptions) {
      subscription.emit("close", subscription);
    }
  }
};
function mergeFilters(filters) {
  const result = {};
  filters.forEach((filter) => {
    Object.entries(filter).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        if (result[key] === void 0) {
          result[key] = [...value];
        } else {
          result[key] = Array.from(/* @__PURE__ */ new Set([...result[key], ...value]));
        }
      } else {
        result[key] = value;
      }
    });
  });
  return result;
}
function filterFromId(id) {
  let decoded;
  try {
    decoded = import_nostr_tools8.nip19.decode(id);
    switch (decoded.type) {
      case "nevent":
        return { ids: [decoded.data.id] };
      case "note":
        return { ids: [decoded.data] };
      case "naddr":
        return {
          authors: [decoded.data.pubkey],
          "#d": [decoded.data.identifier],
          kinds: [decoded.data.kind]
        };
    }
  } catch (e) {
  }
  return { ids: [id] };
}
function generateFilterId(filter) {
  const keys = Object.keys(filter) || [];
  const subId = [];
  for (const key of keys) {
    if (key === "kinds") {
      const v = [key, filter.kinds.join(",")];
      subId.push(v.join(":"));
    } else {
      subId.push(key);
    }
  }
  subId.push(Math.floor(Math.random() * 999999999).toString());
  return subId.join("-");
}

// src/relay/sets/index.ts
var NDKRelaySet2 = class {
  relays;
  debug;
  ndk;
  constructor(relays, ndk) {
    this.relays = relays;
    this.ndk = ndk;
    this.debug = ndk.debug.extend("relayset");
  }
  /**
   * Creates a relay set from a list of relay URLs.
   *
   * This is useful for testing in development to pass a local relay
   * to publish methods.
   *
   * @param relayUrls - list of relay URLs to include in this set
   * @param ndk
   * @returns NDKRelaySet
   */
  static fromRelayUrls(relayUrls, ndk) {
    const relays = /* @__PURE__ */ new Set();
    for (const url of relayUrls) {
      const relay = ndk.pool.relays.get(url);
      if (relay) {
        relays.add(relay);
      }
    }
    return new NDKRelaySet2(new Set(relays), ndk);
  }
  subscribeOnRelay(relay, subscription) {
    const sub = relay.subscribe(subscription);
    subscription.relaySubscriptions.set(relay, sub);
  }
  /**
   * Calculates an ID of this specific combination of relays.
   */
  getId() {
    const urls = Array.from(this.relays).map((r) => r.url);
    const urlString = urls.sort().join(",");
    return (0, import_utils2.bytesToHex)((0, import_sha256.sha256)(urlString));
  }
  /**
   * Add a subscription to this relay set
   */
  subscribe(subscription) {
    const subGroupableId = subscription.groupableId();
    const groupableId = `${this.getId()}:${subGroupableId}`;
    if (!subGroupableId) {
      this.executeSubscription(subscription);
      return subscription;
    }
    const delayedSubscription = this.ndk.delayedSubscriptions.get(groupableId);
    if (delayedSubscription) {
      delayedSubscription.push(subscription);
    } else {
      setTimeout(() => {
        this.executeDelayedSubscription(groupableId);
      }, subscription.opts.groupableDelay);
      this.ndk.delayedSubscriptions.set(groupableId, [subscription]);
    }
    return subscription;
  }
  executeDelayedSubscription(groupableId) {
    const subscriptions = this.ndk.delayedSubscriptions.get(groupableId);
    this.ndk.delayedSubscriptions.delete(groupableId);
    if (subscriptions) {
      if (subscriptions.length > 1) {
        this.executeSubscriptions(subscriptions);
      } else {
        this.executeSubscription(subscriptions[0]);
      }
    }
  }
  /**
   * This function takes a similar group of subscriptions, merges the filters
   * and sends a single subscription to the relay.
   */
  executeSubscriptions(subscriptions) {
    const ndk = subscriptions[0].ndk;
    const subGroup = new NDKSubscriptionGroup(ndk, subscriptions);
    this.executeSubscription(subGroup);
  }
  executeSubscription(subscription) {
    this.debug("subscribing", { filter: subscription.filter });
    for (const relay of this.relays) {
      if (relay.status === 1 /* CONNECTED */) {
        this.subscribeOnRelay(relay, subscription);
      } else {
        const connectedListener = () => {
          this.debug("new relay coming online for active subscription", {
            relay: relay.url,
            filter: subscription.filter
          });
          this.subscribeOnRelay(relay, subscription);
        };
        relay.once("connect", connectedListener);
        subscription.once("close", () => {
          relay.removeListener("connect", connectedListener);
        });
      }
    }
    return subscription;
  }
  /**
   * Publish an event to all relays in this set. Returns the number of relays that have received the event.
   * @param event
   * @param timeoutMs - timeout in milliseconds for each publish operation and connection operation
   * @returns A set where the event was successfully published to
   */
  async publish(event, timeoutMs) {
    const publishedToRelays = /* @__PURE__ */ new Set();
    const promises = Array.from(this.relays).map((relay) => {
      return new Promise((resolve) => {
        relay.publish(event, timeoutMs).then(() => {
          publishedToRelays.add(relay);
          resolve();
        }).catch((err) => {
          this.debug("error publishing to relay", { relay: relay.url, err });
          resolve();
        });
      });
    });
    await Promise.all(promises);
    if (publishedToRelays.size === 0) {
      throw new Error("No relay was able to receive the event");
    }
    return publishedToRelays;
  }
  size() {
    return this.relays.size;
  }
};

// src/relay/sets/calculate.ts
function calculateRelaySetFromEvent(ndk, event) {
  const relays = /* @__PURE__ */ new Set();
  ndk.pool?.relays.forEach((relay) => relays.add(relay));
  return new NDKRelaySet2(relays, ndk);
}
function calculateRelaySetFromFilter(ndk, filter) {
  const relays = /* @__PURE__ */ new Set();
  ndk.pool?.relays.forEach((relay) => {
    if (!relay.complaining) {
      relays.add(relay);
    } else {
      ndk.debug(`Relay ${relay.url} is complaining, not adding to set`);
    }
  });
  return new NDKRelaySet2(relays, ndk);
}

// src/events/kinds/lists/index.ts
var NDKList = class extends NDKEvent {
  _encryptedTags;
  /**
   * Stores the number of bytes the content was before decryption
   * to expire the cache when the content changes.
   */
  encryptedTagsLength;
  constructor(ndk, rawEvent) {
    super(ndk, rawEvent);
    if (!this.kind)
      this.kind = 30001 /* CategorizedBookmarkList */;
  }
  /**
   * Wrap a NDKEvent into a NDKList
   */
  static from(ndkEvent) {
    return new NDKList(ndkEvent.ndk, ndkEvent.rawEvent());
  }
  /**
   * Returns the name of the list.
   */
  get name() {
    return this.tagValue("name") ?? this.tagValue("d");
  }
  /**
   * Sets the name of the list.
   */
  set name(name) {
    this.removeTag("name");
    if (name) {
      this.tags.push(["name", name]);
    } else {
      throw new Error("Name cannot be empty");
    }
  }
  /**
   * Returns the description of the list.
   */
  get description() {
    return this.tagValue("description");
  }
  /**
   * Sets the description of the list.
   */
  set description(name) {
    if (name) {
      this.tags.push(["description", name]);
    } else {
      this.removeTag("description");
    }
  }
  isEncryptedTagsCacheValid() {
    return !!(this._encryptedTags && this.encryptedTagsLength === this.content.length);
  }
  /**
   * Returns the decrypted content of the list.
   */
  async encryptedTags(useCache = true) {
    if (useCache && this.isEncryptedTagsCacheValid())
      return this._encryptedTags;
    if (!this.ndk)
      throw new Error("NDK instance not set");
    if (!this.ndk.signer)
      throw new Error("NDK signer not set");
    const user = await this.ndk.signer.user();
    try {
      if (this.content.length > 0) {
        try {
          const decryptedContent = await this.ndk.signer.decrypt(user, this.content);
          const a = JSON.parse(decryptedContent);
          if (a && a[0]) {
            this.encryptedTagsLength = this.content.length;
            return this._encryptedTags = a;
          }
          this.encryptedTagsLength = this.content.length;
          return this._encryptedTags = [];
        } catch (e) {
          console.log(`error decrypting ${this.content}`);
        }
      }
    } catch (e) {
    }
    return [];
  }
  /**
   * This method can be overriden to validate that a tag is valid for this list.
   *
   * (i.e. the NDKPersonList can validate that items are NDKUser instances)
   */
  validateTag(tagValue) {
    return true;
  }
  /**
   * Returns the unecrypted items in this list.
   */
  get items() {
    return this.tags.filter((t) => {
      return !["d", "name", "description"].includes(t[0]);
    });
  }
  /**
   * Adds a new item to the list.
   * @param relay Relay to add
   * @param mark Optional mark to add to the item
   * @param encrypted Whether to encrypt the item
   */
  async addItem(item, mark = void 0, encrypted = false) {
    if (!this.ndk)
      throw new Error("NDK instance not set");
    if (!this.ndk.signer)
      throw new Error("NDK signer not set");
    let tag;
    if (item instanceof NDKEvent) {
      tag = item.tagReference();
    } else if (item instanceof NDKUser) {
      tag = item.tagReference();
    } else if (item instanceof NDKRelay2) {
      tag = item.tagReference();
    } else if (Array.isArray(item)) {
      tag = item;
    } else {
      throw new Error("Invalid object type");
    }
    if (mark)
      tag.push(mark);
    if (encrypted) {
      const user = await this.ndk.signer.user();
      const currentList = await this.encryptedTags();
      currentList.push(tag);
      this._encryptedTags = currentList;
      this.encryptedTagsLength = this.content.length;
      this.content = JSON.stringify(currentList);
      await this.encrypt(user);
    } else {
      this.tags.push(tag);
    }
    this.created_at = Math.floor(Date.now() / 1e3);
    this.emit("change");
  }
  /**
   * Removes an item from the list.
   *
   * @param index The index of the item to remove.
   * @param encrypted Whether to remove from the encrypted list or not.
   */
  async removeItem(index, encrypted) {
    if (!this.ndk)
      throw new Error("NDK instance not set");
    if (!this.ndk.signer)
      throw new Error("NDK signer not set");
    if (encrypted) {
      const user = await this.ndk.signer.user();
      const currentList = await this.encryptedTags();
      currentList.splice(index, 1);
      this._encryptedTags = currentList;
      this.encryptedTagsLength = this.content.length;
      this.content = JSON.stringify(currentList);
      await this.encrypt(user);
    } else {
      this.tags.splice(index, 1);
    }
    this.created_at = Math.floor(Date.now() / 1e3);
    this.emit("change");
    return this;
  }
};

// src/signers/nip07/index.ts
var import_debug2 = __toESM(require("debug"));
var NDKNip07Signer = class {
  _userPromise;
  nip04Queue = [];
  nip04Processing = false;
  debug;
  constructor() {
    if (!window.nostr) {
      throw new Error("NIP-07 extension not available");
    }
    this.debug = (0, import_debug2.default)("ndk:nip07");
  }
  async blockUntilReady() {
    const pubkey = await window.nostr?.getPublicKey();
    if (!pubkey) {
      throw new Error("User rejected access");
    }
    return new NDKUser({ hexpubkey: pubkey });
  }
  /**
   * Getter for the user property.
   * @returns The NDKUser instance.
   */
  async user() {
    if (!this._userPromise) {
      this._userPromise = this.blockUntilReady();
    }
    return this._userPromise;
  }
  /**
   * Signs the given Nostr event.
   * @param event - The Nostr event to be signed.
   * @returns The signature of the signed event.
   * @throws Error if the NIP-07 is not available on the window object.
   */
  async sign(event) {
    if (!window.nostr) {
      throw new Error("NIP-07 extension not available");
    }
    const signedEvent = await window.nostr.signEvent(event);
    return signedEvent.sig;
  }
  async encrypt(recipient, value) {
    if (!window.nostr) {
      throw new Error("NIP-07 extension not available");
    }
    const recipientHexPubKey = recipient.hexpubkey();
    return this.queueNip04("encrypt", recipientHexPubKey, value);
  }
  async decrypt(sender, value) {
    if (!window.nostr) {
      throw new Error("NIP-07 extension not available");
    }
    const senderHexPubKey = sender.hexpubkey();
    return this.queueNip04("decrypt", senderHexPubKey, value);
  }
  async queueNip04(type, counterpartyHexpubkey, value) {
    return new Promise((resolve, reject) => {
      this.nip04Queue.push({ type, counterpartyHexpubkey, value, resolve, reject });
      if (!this.nip04Processing) {
        this.processNip04Queue();
      }
    });
  }
  async processNip04Queue(item, retries = 0) {
    if (!item && this.nip04Queue.length === 0) {
      this.nip04Processing = false;
      return;
    }
    this.nip04Processing = true;
    const { type, counterpartyHexpubkey, value, resolve, reject } = item || this.nip04Queue.shift();
    this.debug("Processing encryption queue item", { type, counterpartyHexpubkey, value });
    try {
      let result;
      if (type === "encrypt") {
        result = await window.nostr.nip04.encrypt(counterpartyHexpubkey, value);
      } else {
        result = await window.nostr.nip04.decrypt(counterpartyHexpubkey, value);
      }
      resolve(result);
    } catch (error) {
      if (error.message && error.message.includes("call already executing")) {
        if (retries < 5) {
          this.debug("Retrying encryption queue item", { type, counterpartyHexpubkey, value, retries });
          setTimeout(() => {
            this.processNip04Queue(item, retries + 1);
          }, 50 * retries);
          return;
        }
      }
      reject(error);
    }
    this.processNip04Queue();
  }
};

// src/signers/nip46/rpc.ts
var import_eventemitter36 = __toESM(require("eventemitter3"));
var NDKNostrRpc = class extends import_eventemitter36.default {
  ndk;
  signer;
  debug;
  constructor(ndk, signer, debug4) {
    super();
    this.ndk = ndk;
    this.signer = signer;
    this.debug = debug4.extend("rpc");
  }
  /**
   * Subscribe to a filter. This function will resolve once the subscription is ready.
   */
  async subscribe(filter) {
    const sub = this.ndk.subscribe(filter, { closeOnEose: false });
    sub.on("event", async (event) => {
      try {
        const parsedEvent = await this.parseEvent(event);
        if (parsedEvent.method) {
          this.emit("request", parsedEvent);
        } else {
          this.emit(`response-${parsedEvent.id}`, parsedEvent);
        }
      } catch (e) {
        this.debug("error parsing event", e, event);
      }
    });
    return new Promise((resolve, reject) => {
      sub.on("eose", () => resolve(sub));
    });
  }
  async parseEvent(event) {
    const remoteUser = this.ndk.getUser({ hexpubkey: event.pubkey });
    remoteUser.ndk = this.ndk;
    const decryptedContent = await this.signer.decrypt(remoteUser, event.content);
    const parsedContent = JSON.parse(decryptedContent);
    const { id, method, params, result, error } = parsedContent;
    if (method) {
      return { id, pubkey: event.pubkey, method, params, event };
    } else {
      return { id, result, error, event };
    }
  }
  async sendResponse(id, remotePubkey, result, kind = 24133, error) {
    const res = { id, result };
    if (error) {
      res.error = error;
    }
    const localUser = await this.signer.user();
    const remoteUser = this.ndk.getUser({ hexpubkey: remotePubkey });
    const event = new NDKEvent(this.ndk, {
      kind,
      content: JSON.stringify(res),
      tags: [["p", remotePubkey]],
      pubkey: localUser.hexpubkey()
    });
    event.content = await this.signer.encrypt(remoteUser, event.content);
    await event.sign(this.signer);
    await this.ndk.publish(event);
  }
  /**
   * Sends a request.
   * @param remotePubkey
   * @param method
   * @param params
   * @param kind
   * @param id
   */
  async sendRequest(remotePubkey, method, params = [], kind = 24133, cb) {
    const id = Math.random().toString(36).substring(7);
    const localUser = await this.signer.user();
    const remoteUser = this.ndk.getUser({ hexpubkey: remotePubkey });
    const request = { id, method, params };
    const promise = new Promise((resolve) => {
      if (cb)
        this.once(`response-${id}`, cb);
    });
    const event = new NDKEvent(this.ndk, {
      kind,
      content: JSON.stringify(request),
      tags: [["p", remotePubkey]],
      pubkey: localUser.hexpubkey()
    });
    event.content = await this.signer.encrypt(remoteUser, event.content);
    await event.sign(this.signer);
    this.debug("sending request to", remotePubkey);
    await this.ndk.publish(event);
    return promise;
  }
};

// src/signers/nip46/backend/connect.ts
var ConnectEventHandlingStrategy = class {
  async handle(backend, remotePubkey, params) {
    const [pubkey, token] = params;
    const debug4 = backend.debug.extend("connect");
    debug4(`connection request from ${pubkey}`);
    if (token && backend.applyToken) {
      debug4(`applying token`);
      await backend.applyToken(pubkey, token);
    }
    if (await backend.pubkeyAllowed(pubkey, "connect", token)) {
      debug4(`connection request from ${pubkey} allowed`);
      return "ack";
    } else {
      debug4(`connection request from ${pubkey} rejected`);
    }
    return void 0;
  }
};

// src/signers/nip46/backend/describe.ts
var DescribeHandlingStrategy = class {
  async handle(backend, remotePubkey, params) {
    const keys = Object.keys(backend.handlers);
    return JSON.stringify(keys);
  }
};

// src/signers/nip46/backend/get-public-key.ts
var GetPublicKeyHandlingStrategy = class {
  async handle(backend, remotePubkey, params) {
    return backend.localUser?.hexpubkey();
  }
};

// src/signers/nip46/backend/sign-event.ts
var SignEventHandlingStrategy = class {
  async handle(backend, remotePubkey, params) {
    const event = await backend.signEvent(remotePubkey, params);
    if (!event)
      return void 0;
    return JSON.stringify(await event.toNostrEvent());
  }
};

// src/signers/nip46/backend/nip04-decrypt.ts
var Nip04DecryptHandlingStrategy = class {
  async handle(backend, remotePubkey, params) {
    const [senderPubkey, payload] = params;
    const senderUser = new NDKUser({ hexpubkey: senderPubkey });
    const decryptedPayload = await backend.decrypt(remotePubkey, senderUser, payload);
    return JSON.stringify([decryptedPayload]);
  }
};

// src/signers/nip46/backend/nip04-encrypt.ts
var Nip04EncryptHandlingStrategy = class {
  async handle(backend, remotePubkey, params) {
    const [recipientPubkey, payload] = params;
    const recipientUser = new NDKUser({ hexpubkey: recipientPubkey });
    const decryptedPayload = await backend.encrypt(remotePubkey, recipientUser, payload);
    return decryptedPayload;
  }
};

// src/signers/nip46/backend/index.ts
var import_nostr_tools9 = require("nostr-tools");
var NDKNip46Backend = class {
  ndk;
  signer;
  localUser;
  debug;
  rpc;
  permitCallback;
  /**
   * @param ndk The NDK instance to use
   * @param privateKey The private key of the npub that wants to be published as
   */
  constructor(ndk, privateKey, permitCallback) {
    this.ndk = ndk;
    this.signer = new NDKPrivateKeySigner(privateKey);
    this.debug = ndk.debug.extend("nip46:backend");
    this.rpc = new NDKNostrRpc(ndk, this.signer, this.debug);
    this.permitCallback = permitCallback;
  }
  /**
   * This method starts the backend, which will start listening for incoming
   * requests.
   */
  async start() {
    this.localUser = await this.signer.user();
    const sub = this.ndk.subscribe(
      {
        kinds: [24133],
        "#p": [this.localUser.hexpubkey()]
      },
      { closeOnEose: false }
    );
    sub.on("event", (e) => this.handleIncomingEvent(e));
  }
  handlers = {
    connect: new ConnectEventHandlingStrategy(),
    sign_event: new SignEventHandlingStrategy(),
    nip04_encrypt: new Nip04EncryptHandlingStrategy(),
    nip04_decrypt: new Nip04DecryptHandlingStrategy(),
    get_public_key: new GetPublicKeyHandlingStrategy(),
    describe: new DescribeHandlingStrategy()
  };
  /**
   * Enables the user to set a custom strategy for handling incoming events.
   * @param method - The method to set the strategy for
   * @param strategy - The strategy to set
   */
  setStrategy(method, strategy) {
    this.handlers[method] = strategy;
  }
  /**
   * Overload this method to apply tokens, which can
   * wrap permission sets to be applied to a pubkey.
   * @param pubkey public key to apply token to
   * @param token token to apply
   */
  async applyToken(pubkey, token) {
    throw new Error("connection token not supported");
  }
  async handleIncomingEvent(event) {
    const { id, method, params } = await this.rpc.parseEvent(event);
    const remotePubkey = event.pubkey;
    let response;
    this.debug("incoming event", { id, method, params });
    if (!(0, import_nostr_tools9.verifySignature)(event.rawEvent())) {
      this.debug("invalid signature", event.rawEvent());
      return;
    }
    const strategy = this.handlers[method];
    if (strategy) {
      try {
        response = await strategy.handle(this, remotePubkey, params);
      } catch (e) {
        this.debug("error handling event", e, { id, method, params });
        this.rpc.sendResponse(id, remotePubkey, "error", void 0, e.message);
      }
    } else {
      this.debug("unsupported method", { method, params });
    }
    if (response) {
      this.debug(`sending response to ${remotePubkey}`, response);
      this.rpc.sendResponse(id, remotePubkey, response);
    } else {
      this.rpc.sendResponse(id, remotePubkey, "error", void 0, "Not authorized");
    }
  }
  async decrypt(remotePubkey, senderUser, payload) {
    if (!await this.pubkeyAllowed(remotePubkey, "decrypt", payload)) {
      this.debug(`decrypt request from ${remotePubkey} rejected`);
      return void 0;
    }
    return await this.signer.decrypt(senderUser, payload);
  }
  async encrypt(remotePubkey, recipientUser, payload) {
    if (!await this.pubkeyAllowed(remotePubkey, "encrypt", payload)) {
      this.debug(`encrypt request from ${remotePubkey} rejected`);
      return void 0;
    }
    return await this.signer.encrypt(recipientUser, payload);
  }
  async signEvent(remotePubkey, params) {
    const [eventString] = params;
    this.debug(`sign event request from ${remotePubkey}`);
    const event = new NDKEvent(this.ndk, JSON.parse(eventString));
    this.debug("event to sign", event.rawEvent());
    if (!await this.pubkeyAllowed(remotePubkey, "sign_event", event)) {
      this.debug(`sign event request from ${remotePubkey} rejected`);
      return void 0;
    }
    this.debug(`sign event request from ${remotePubkey} allowed`);
    await event.sign(this.signer);
    return event;
  }
  /**
   * This method should be overriden by the user to allow or reject incoming
   * connections.
   */
  async pubkeyAllowed(pubkey, method, params) {
    return this.permitCallback(pubkey, method, params);
  }
};

// src/signers/nip46/index.ts
var NDKNip46Signer = class {
  ndk;
  remoteUser;
  remotePubkey;
  token;
  localSigner;
  rpc;
  debug;
  /**
   * @param ndk - The NDK instance to use
   * @param tokenOrRemotePubkey - The public key, or a connection token, of the npub that wants to be published as
   * @param localSigner - The signer that will be used to request events to be signed
   */
  constructor(ndk, tokenOrRemotePubkey, localSigner) {
    let remotePubkey;
    let token;
    if (tokenOrRemotePubkey.includes("#")) {
      const parts = tokenOrRemotePubkey.split("#");
      remotePubkey = new NDKUser({ npub: parts[0] }).hexpubkey();
      token = parts[1];
    } else if (tokenOrRemotePubkey.startsWith("npub")) {
      remotePubkey = new NDKUser({ npub: tokenOrRemotePubkey }).hexpubkey();
    } else {
      remotePubkey = tokenOrRemotePubkey;
    }
    this.ndk = ndk;
    this.remotePubkey = remotePubkey;
    this.token = token;
    this.debug = ndk.debug.extend("nip46:signer");
    this.remoteUser = new NDKUser({ hexpubkey: remotePubkey });
    if (!localSigner) {
      this.localSigner = NDKPrivateKeySigner.generate();
    } else {
      this.localSigner = localSigner;
    }
    this.rpc = new NDKNostrRpc(ndk, this.localSigner, this.debug);
  }
  /**
   * Get the user that is being published as
   */
  async user() {
    return this.remoteUser;
  }
  async blockUntilReady() {
    const localUser = await this.localSigner.user();
    const user = this.ndk.getUser({ npub: localUser.npub });
    await this.rpc.subscribe({
      kinds: [24133],
      "#p": [localUser.hexpubkey()]
    });
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        const connectParams = [localUser.hexpubkey()];
        if (this.token) {
          connectParams.push(this.token);
        }
        this.rpc.sendRequest(
          this.remotePubkey,
          "connect",
          connectParams,
          24133,
          (response) => {
            if (response.result === "ack") {
              resolve(user);
            } else {
              reject(response.error);
            }
          }
        );
      }, 100);
    });
  }
  async encrypt(recipient, value) {
    this.debug("asking for encryption");
    const promise = new Promise((resolve, reject) => {
      this.rpc.sendRequest(
        this.remotePubkey,
        "nip04_encrypt",
        [recipient.hexpubkey(), value],
        24133,
        (response) => {
          if (!response.error) {
            resolve(response.result);
          } else {
            reject(response.error);
          }
        }
      );
    });
    return promise;
  }
  async decrypt(sender, value) {
    this.debug("asking for decryption");
    const promise = new Promise((resolve, reject) => {
      this.rpc.sendRequest(
        this.remotePubkey,
        "nip04_decrypt",
        [sender.hexpubkey(), value],
        24133,
        (response) => {
          if (!response.error) {
            const value2 = JSON.parse(response.result);
            resolve(value2[0]);
          } else {
            reject(response.error);
          }
        }
      );
    });
    return promise;
  }
  async sign(event) {
    this.debug("asking for a signature");
    const promise = new Promise((resolve, reject) => {
      this.rpc.sendRequest(
        this.remotePubkey,
        "sign_event",
        [JSON.stringify(event)],
        24133,
        (response) => {
          this.debug("got a response", response);
          if (!response.error) {
            const json = JSON.parse(response.result);
            resolve(json.sig);
          } else {
            reject(response.error);
          }
        }
      );
    });
    return promise;
  }
};

// src/signers/private-key/index.ts
var import_nostr_tools10 = require("nostr-tools");
var NDKPrivateKeySigner = class {
  _user;
  privateKey;
  constructor(privateKey) {
    if (privateKey) {
      this.privateKey = privateKey;
      this._user = new NDKUser({ hexpubkey: (0, import_nostr_tools10.getPublicKey)(this.privateKey) });
    }
  }
  static generate() {
    const privateKey = (0, import_nostr_tools10.generatePrivateKey)();
    return new NDKPrivateKeySigner(privateKey);
  }
  async blockUntilReady() {
    if (!this._user) {
      throw new Error("NDKUser not initialized");
    }
    return this._user;
  }
  async user() {
    await this.blockUntilReady();
    return this._user;
  }
  async sign(event) {
    if (!this.privateKey) {
      throw Error("Attempted to sign without a private key");
    }
    return (0, import_nostr_tools10.getSignature)(event, this.privateKey);
  }
  async encrypt(recipient, value) {
    if (!this.privateKey) {
      throw Error("Attempted to encrypt without a private key");
    }
    const recipientHexPubKey = recipient.hexpubkey();
    return await import_nostr_tools10.nip04.encrypt(this.privateKey, recipientHexPubKey, value);
  }
  async decrypt(sender, value) {
    if (!this.privateKey) {
      throw Error("Attempted to decrypt without a private key");
    }
    const senderHexPubKey = sender.hexpubkey();
    return await import_nostr_tools10.nip04.decrypt(this.privateKey, senderHexPubKey, value);
  }
};

// src/zap/invoice.ts
var import_light_bolt11_decoder = require("light-bolt11-decoder");
function zapInvoiceFromEvent(event) {
  const description = event.getMatchingTags("description")[0];
  const bolt11 = event.getMatchingTags("bolt11")[0];
  let decodedInvoice;
  let zapRequest;
  if (!description || !bolt11 || !bolt11[1]) {
    return null;
  }
  try {
    let zapRequestPayload = description[1];
    if (zapRequestPayload.startsWith("%")) {
      zapRequestPayload = decodeURIComponent(zapRequestPayload);
    }
    if (zapRequestPayload === "") {
      return null;
    }
    zapRequest = JSON.parse(zapRequestPayload);
    decodedInvoice = (0, import_light_bolt11_decoder.decode)(bolt11[1]);
  } catch (e) {
    return null;
  }
  const amountSection = decodedInvoice.sections.find((s) => s.name === "amount");
  if (!amountSection) {
    return null;
  }
  const amount = parseInt(amountSection.value);
  if (!amount) {
    return null;
  }
  const content = zapRequest.content;
  const sender = zapRequest.pubkey;
  const recipientTag = event.getMatchingTags("p")[0];
  const recipient = recipientTag[1];
  let zappedEvent = event.getMatchingTags("e")[0];
  if (!zappedEvent) {
    zappedEvent = event.getMatchingTags("a")[0];
  }
  const zappedEventId = zappedEvent ? zappedEvent[1] : void 0;
  const zapInvoice = {
    id: event.id,
    zapper: event.pubkey,
    zappee: sender,
    zapped: recipient,
    zappedEvent: zappedEventId,
    amount,
    comment: content
  };
  return zapInvoice;
}

// src/index.ts
var NDK7 = class extends import_eventemitter37.default {
  pool;
  signer;
  cacheAdapter;
  debug;
  devWriteRelaySet;
  delayedSubscriptions;
  constructor(opts = {}) {
    super();
    this.debug = opts.debug || (0, import_debug3.default)("ndk");
    this.pool = new NDKPool(opts.explicitRelayUrls || [], this);
    this.signer = opts.signer;
    this.cacheAdapter = opts.cacheAdapter;
    this.delayedSubscriptions = /* @__PURE__ */ new Map();
    if (opts.devWriteRelayUrls) {
      this.devWriteRelaySet = NDKRelaySet2.fromRelayUrls(opts.devWriteRelayUrls, this);
    }
  }
  toJSON() {
    return { relayCount: this.pool.relays.size }.toString();
  }
  /**
   * Connect to relays with optional timeout.
   * If the timeout is reached, the connection will be continued to be established in the background.
   */
  async connect(timeoutMs) {
    this.debug("Connecting to relays", { timeoutMs });
    return this.pool.connect(timeoutMs);
  }
  /**
   * Get a NDKUser object
   *
   * @param opts
   * @returns
   */
  getUser(opts) {
    const user = new NDKUser(opts);
    user.ndk = this;
    return user;
  }
  /**
   * Create a new subscription. Subscriptions automatically start and finish when all relays
   * on the set send back an EOSE. (set `opts.closeOnEose` to `false` in order avoid this)
   *
   * @param filter
   * @param opts
   * @param relaySet explicit relay set to use
   * @param autoStart automatically start the subscription
   * @returns NDKSubscription
   */
  subscribe(filter, opts, relaySet, autoStart = true) {
    const subscription = new NDKSubscription(this, filter, opts, relaySet);
    if (autoStart)
      subscription.start();
    return subscription;
  }
  /**
   * Publish an event to a relay
   * @param event event to publish
   * @param relaySet explicit relay set to use
   * @param timeoutMs timeout in milliseconds to wait for the event to be published
   * @returns The relays the event was published to
   */
  async publish(event, relaySet, timeoutMs) {
    if (!relaySet) {
      relaySet = this.devWriteRelaySet || calculateRelaySetFromEvent(this, event);
    }
    return relaySet.publish(event, timeoutMs);
  }
  async fetchEvent(idOrFilter, opts = {}, relaySet) {
    let filter;
    if (typeof idOrFilter === "string") {
      filter = filterFromId(idOrFilter);
    } else {
      filter = idOrFilter;
    }
    if (!filter) {
      throw new Error(`Invalid filter: ${JSON.stringify(idOrFilter)}`);
    }
    return new Promise((resolve) => {
      const s = this.subscribe(filter, { ...opts, closeOnEose: true }, relaySet, false);
      s.on("event", (event) => {
        event.ndk = this;
        resolve(event);
      });
      s.on("eose", () => {
        resolve(null);
      });
      s.start();
    });
  }
  /**
   * Fetch events
   */
  async fetchEvents(filter, opts = {}, relaySet) {
    return new Promise((resolve) => {
      const events = /* @__PURE__ */ new Map();
      const relaySetSubscription = this.subscribe(filter, { ...opts, closeOnEose: true }, relaySet, false);
      relaySetSubscription.on("event", (event) => {
        const existingEvent = events.get(event.tagId());
        if (existingEvent) {
          event = dedup(existingEvent, event);
        }
        event.ndk = this;
        events.set(event.tagId(), event);
      });
      relaySetSubscription.on("eose", () => {
        resolve(new Set(events.values()));
      });
      relaySetSubscription.start();
    });
  }
  /**
   * Ensures that a signer is available to sign an event.
   */
  async assertSigner() {
    if (!this.signer) {
      this.emit("signerRequired");
      throw new Error("Signer required");
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  NDKEvent,
  NDKKind,
  NDKList,
  NDKNip07Signer,
  NDKNip46Backend,
  NDKNip46Signer,
  NDKNostrRpc,
  NDKPrivateKeySigner,
  NDKRelay,
  NDKRelaySet,
  NDKRelayStatus,
  NDKSubscription,
  NDKSubscriptionCacheUsage,
  NDKSubscriptionGroup,
  NDKUser,
  defaultOpts,
  filterFromId,
  mergeEvent,
  mergeFilters,
  zapInvoiceFromEvent
});
